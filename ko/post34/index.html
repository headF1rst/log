<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/log/site.webmanifest"/><link rel="mask-icon" href="/log/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>AI 브라우저를 활용한 PR 메세지 자동화</title><meta name="title" content="AI 브라우저를 활용한 PR 메세지 자동화"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="AI 브라우저를 활용한 PR 메세지 자동화"/><meta property="og:url" content="https://headf1rst.github.io/log/ko/post34"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://i.imgur.com/iJY5NAV.png"/><meta property="og:description"/><link rel="alternate" hrefLang="ko" href="https://headf1rst.github.io/log/ko/post34"/><link rel="alternate" hrefLang="x-default" href="https://headf1rst.github.io/log/ko/post34"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"TechArticle","headline":"AI 브라우저를 활용한 PR 메세지 자동화","datePublished":"2025-12-14","dateModified":"2025-12-14","author":{"@type":"Person","name":"Sanha Ko","url":"https://github.com/headF1rst"},"description":"","image":"https://i.imgur.com/iJY5NAV.png","url":"https://headf1rst.github.io/log/ko/post34","keywords":"AI","inLanguage":"ko-KR","about":[{"@type":"Thing","name":"AI"}],"programmingLanguage":"Java, Kotlin, JavaScript, TypeScript","publisher":{"@type":"Organization","name":"산하개발실록","logo":{"@type":"ImageObject","url":"https://i.imgur.com/JtjOEf3.png"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://headf1rst.github.io/log/ko/post34"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://headf1rst.github.io/log/ko"},{"@type":"ListItem","position":2,"name":"AI 브라우저를 활용한 PR 메세지 자동화","item":"https://headf1rst.github.io/log/ko/post34"}]}</script><meta name="next-head-count" content="26"/><link rel="preload" href="/log/_next/static/css/12f1bbdb773e9471.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/12f1bbdb773e9471.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/log/_next/static/chunks/webpack-82b4c2acf5604dc5.js" defer=""></script><script src="/log/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/log/_next/static/chunks/main-6e6d6dc6617c8481.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-3cbbaf6a90de61d5.js" defer=""></script><script src="/log/_next/static/chunks/9f96d65d-fb5fd9e6ccafc67e.js" defer=""></script><script src="/log/_next/static/chunks/259-59cbd4b09a9629be.js" defer=""></script><script src="/log/_next/static/chunks/819-49378f41c4211145.js" defer=""></script><script src="/log/_next/static/chunks/pages/%5Blang%5D/%5Bid%5D-c173481abf3f6953.js" defer=""></script><script src="/log/_next/static/vjSj3GbVwS7vkZ0Aa3KlF/_buildManifest.js" defer=""></script><script src="/log/_next/static/vjSj3GbVwS7vkZ0Aa3KlF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/log/ko/"><div class="flex items-center gap-2 cursor-pointer"><h1 class="text-lg ">JustAnotherBlog</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden items-center"><a href="/log/ko/"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/log/ko/?section=tech"><button class="font-light hover:text-indigo-300 text-base">Tech</button></a><a href="/log/ko/?section=domain"><button class="font-light hover:text-indigo-300 text-base">Domain</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a><div class="relative"><button class="flex items-center gap-1 hover:text-indigo-300 text-base font-light">🇰🇷<!-- --> <!-- -->한국어</button></div></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">AI 브라우저를 활용한 PR 메세지 자동화</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2025-12-14</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">AI</span></div></div><div class="flex items-center gap-2"><span class="text-sm text-gray-400">🇺🇸 영어로 읽기</span></div><div class="markdown-body" style="font-size:17px"><p>개발자에게 &quot;코드 작성&quot;과 &quot;PR(Pull Request) 작성&quot; 중 무엇이 더 고통스러운지 묻는다면, 의외로 많은 분이 후자를 택합니다. 구현은 즐겁지만, 그것을 남에게 글로 설명하는데는 생각보다 상당한 시간이 소모되기 때문입니다.</p>
<p>최근 Copilot이나 IntelliJ AI 등 다양한 도구가 등장하며 PR 작성을 돕고 있지만, 여전히 &#x27;2%&#x27; 부족함을 느낍니다. 오늘은 그 부족한 2%를 채우고, 리뷰어와 작성자 모두가 행복해지는 PR 자동화 워크플로우를 공유하고자 합니다.</p>
<h2>1. 좋은 Pull Request 란?</h2>
<p>기술적인 자동화를 논하기 전에, 우리가 작성해야 할 &#x27;좋은 PR&#x27;의 정의부터 명확히 해야 합니다.</p>
<p>좋은 PR의 핵심은 **&#x27;리뷰어에 대한 공감&#x27;**입니다. 리뷰어는 바쁜 시간을 쪼개서 코드를 봅니다. 리뷰어의 시간을 아껴주고, 코드의 의도를 명확하게 전달하는것이 PR의 가장 중요한 목표입니다.</p>
<h3>좋은 PR의 구성요소</h3>
<ol>
<li>
<p><strong>명확한 맥락:</strong> 단순히 코드가 &#x27;무엇&#x27;이 변했는지는 diff만 봐도 알 수 있습니다. 중요한 것은 **&#x27;왜 이 변경이 필요했는가&#x27;**입니다.</p>
</li>
<li>
<p><strong>직관적 시각 자료:</strong> 백 마디 말보다 한 장의 스크린샷이나 다이어그램이 훨씬 빠른 이해를 돕습니다.</p>
</li>
<li>
<p><strong>작고 집중된 단위:</strong> 하나의 PR은 하나의 이슈만 다루어야 리뷰와 병합의 리스크가 줄어듭니다.</p>
</li>
</ol>
<p>코드 리뷰를 하는 이유 중 하나는 팀원 간의 작업 방향 정렬과 개발 과정에서의 실수 방지입니다.</p>
<p>작업 배경을 상세히 기술하면 리뷰어는 단순히 코드 변경사항만 보는 것이 아니라, 왜 이런 변경이 필요했는지 맥락을 이해할 수 있습니다. 이러한 컨텍스트 공유는 리뷰어가 더 넓은 시야에서 코드를 바라볼 수 있게 하여, 단순 문법적 오류나 컨벤션 위반을 넘어 아키텍처적 개선점, 잠재적 사이드 이펙트, 대안적 접근 방식 등 다양한 관점의 피드백을 제공할 수 있게 됩니다.</p>
<p>결과적으로 배경 설명이 잘 된 PR은 리뷰의 질을 높이고, 팀 전체의 도메인 지식과 시스템 이해도를 향상시키는 효과적인 지식 공유의 수단이 됩니다.</p>
<h2>2. 현재 AI Assistant의 한계: &#x27;맥락&#x27;의 부재</h2>
<p>최근의 생성형 AI 도구들(GitHub Copilot, IntelliJ AI 등)은 코드 변경 사항(Diff)을 요약하는 데 탁월한 능력을 보여줍니다. 버튼 하나만 누르면 아래와 같은 요약을 순식간에 만들어냅니다.</p>
<blockquote>
<p>Copilot Agent가 생성한 PR</p>
</blockquote>
<!-- -->&lt;img src=&quot;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/nof7n7t65c4zkp49cpim.png&quot; alt=&quot;Copilot PR&quot; width=&quot;400&quot;&gt;<!-- -->
<p>그러나 AI가 만든 PR 메시지는 초안으로는 충분하지만, 작업의 배경까지는 담아내지 못해 코드 수정의 근본적인 이유를 파악하기 어렵다는 한계가 있습니다.</p>
<ul>
<li>
<p><strong>배경 정보 누락:</strong> AI는 코드 자체만 보고 요약하므로, &quot;사용자가 특정 상황에서 겪은 불편함&quot;이나 &quot;기획 의도&quot; 같은 외부 맥락을 알지 못합니다.</p>
</li>
<li>
<p><strong>근본적 이유 부재:</strong> 코드를 &#x27;수정했다&#x27;는 사실은 알지만, &#x27;왜 수정해야만 했는지&#x27;에 대한 비즈니스적/기술적 배경은 설명하지 못합니다.</p>
</li>
</ul>
<p>결국, 리뷰어가 가장 궁금해하는 **&#x27;작업 배경&#x27;**을 채우는 일은 여전히 사람의 몫으로 남게 됩니다. 그리고 배경을 간결하고 핵심적으로 정리하는 것은 PR 작성에서 가장 많은 시간을 잡아먹습니다.</p>
<p>이 과정을 AI가 대신할 수 있다면, 리뷰어에게 코드의 의도를 명확하게 전달하면서 PR 작성에 드는 시간을 크게 줄일 수 있을 것입니다.</p>
<h2>3. Jira 티켓에서 맥락 가져오기</h2>
<p>그렇다면 어디서 맥락을 가져올 수 있을까요? 저는 개발을 시작하기 전에 티켓에 해결하고자 하는 문제와 목표를 명확히 정의합니다.</p>
<p>티켓에는 작업을 한눈에 파악할 수 있도록 &quot;무엇을&quot;, &quot;왜&quot; 하는지를 간결하게 담습니다. 예를 들어 &quot;주문 취소 시 재고 복구 실패 이슈 수정&quot;처럼 핵심 문제와 해결 방향을 제목에서부터 드러냅니다.</p>
<p>그 다음 작업의 배경과 목적을 상세히 기술합니다. 현재 어떤 문제가 발생하고 있는지(AS-IS), 왜 이 작업이 필요한지, 어떤 비즈니스 영향이 있는지를 구체적으로 작성하고, 작업을 통해 달성하고자 하는 상태(TO-BE)와 명확한 완료 기준을 함께 정의합니다.</p>
<p>&quot;PR 쓰기도 귀찮은데 Jira까지 자세히 쓰라고요?&quot;라고 반문하실 수 있습니다. 하지만 <strong>문제 정의는 AI가 아닌 사람이 해야 할 영역</strong>입니다. 티켓을 충실히 작성하면 다음과 같은 이점이 있습니다.</p>
<h3>작업 전 Jira 티켓을 풍부하게 작성하면 좋은점</h3>
<ol>
<li>
<p><strong>명확한 목표 설정과 작업 집중</strong>: &quot;로그인 버그 수정&quot;이라는 한 줄짜리 티켓은 &#x27;어떤 상황에서&#x27;, &#x27;어떤 사용자가&#x27;, &#x27;어떻게&#x27; 버그를 겪는지 알려주지 않습니다. 상세한 설명, 재현 방법, 기대 결과가 담긴 티켓은 내가 무엇을 해야 하는지 명확히 알려주어 불필요한 고민 없이 작업에만 집중하게 해줍니다.</p>
</li>
<li>
<p><strong>정확한 계획 수립과 예측 가능성 확보</strong>: 티켓이 상세할수록 작업의 규모와 복잡도를 더 정확하게 예측할 수 있습니다.</p>
</li>
<li>
<p><strong>미래의 나를 위한 기록</strong>: 몇 달 뒤 내가 작성한 코드를 다시 보게 될 때, Jira 티켓은 &quot;내가 왜 이 코드를 이렇게 작성했더라?&quot;에 대한 완벽한 답변이 되어 줍니다. 유지보수와 기능 확장이 훨씬 쉬워집니다.</p>
</li>
</ol>
<h2>4. AI 브라우저로 워크플로우 완성하기</h2>
<p>우리의 목표는 **&quot;PR 작성에 드는 시간과 노력을 최소화하면서, 퀄리티는 극대화하는 것&quot;**입니다. 이를 위해 AI 브라우저인 Commet(혹은 Dia)의 기능을 활용할 수 있습니다.</p>
<p>Commet은 단순한 브라우징을 넘어, 사용자가 자주 사용하는 프롬프트를 <strong>&#x27;Shotcuts&#x27;</strong> 형태로 저장하고 <code node="[object Object]">/Shotcuts</code>로 호출할 수 있는 기능을 제공합니다. 이를 통해 매번 긴 프롬프트를 작성할 필요 없이, Jira의 문맥과 코드 변경 사항을 결합할 수 있습니다.</p>
<h3>자동화 워크플로우</h3>
<ol>
<li>
<p><strong>Jira 티켓 작성:</strong> 작업 전, 이슈의 배경(Why)과 해결 방안(What)을 Jira에 명확히 기록합니다.</p>
</li>
<li>
<p><strong>Commet Shortcuts 등록:</strong> Commet 브라우저에 PR 자동 생성을 위한 Shortcuts를 등록해줍니다.
<img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/n2mgw687c31cvmbf0t44.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
</li>
<li>
<p>PR 수정 화면에서 Commet의 사이드 패널을 열고 미리 등록해 둔 <strong>PR 작성 Shortcuts</strong>을 호출
합니다.</p>
</li>
</ol>
<p>이렇게 하면 AI는 Jira에서 **&#x27;작업의 의도(Why)&#x27;**를 가져오고, Git Diff에서 **&#x27;구현 내용(What)&#x27;**을 가져와 PR 메시지를 생성해 줍니다.</p>
<h2>PR 자동 생성에 사용한 프롬프트</h2>
<p>마지막으로 PR 자동 생성에 사용한 프롬프트를 공유드리며 글을 마무리하도록 하겠습니다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-text" style="white-space:pre"><span>당신은 명확하고 규칙적인 Pull Request 설명을 잘 작성하는 숙련된 소프트웨어 엔지니어입니다.  
</span>당신의 주요 목표는 주어진 Jira 티켓과 PR 세부 정보를 기반으로, 우리 팀의 컨벤션을 **엄격히 준수하는 PR 메시지**를 생성하는 것입니다.
<!-- -->
<!-- -->이 페이지의 브랜치 정보를 참고하고, “ABCD”로 시작하는 관련 Jira 티켓을 열어 그 안에 작성된 맥락(context)을 활용해 Pull Request 설명을 작성하세요.  
<!-- -->아래 링크를 통해 Jira 보드에 접속한 뒤, 해당 DPDD 티켓을 검색하여 열 수 있습니다.
<!-- -->
<!-- -->Jira 보드 링크:  
<!-- -->`https://jiraboard.atlassian.net/jira/software/c/projects/DPDD/boards/5218?assignee=712020%3A8ef336bd-458e-4630-a79f-d0ea76930601`
<!-- -->
<!-- -->PR 메시지는 **한국어로 작성하세요.**
<!-- -->
<!-- -->---
<!-- -->
<!-- -->### 따라야 할 PR 메시지 템플릿
<!-- -->
<!-- -->## 요약 ✍️  
<!-- -->*Jira 티켓과 PR 정보를 기반으로 간결한 요약을 작성하세요.*  
<!-- -->먼저 이번 변경의 **배경과 목적(Why)** 을 설명하고,  
<!-- -->그 다음 **구체적인 변경 내용(What, How)** 을 불릿 포인트로 정리하세요.
<!-- -->
<!-- -->이 문서에 포함된 클래스나 주요 구성요소 간의 관계, 역할, 상호작용을 설명하기 위해  
<!-- -->`mermaid` 다이어그램을 코드 블록 안에 렌더링하세요.  
<!-- -->다이어그램은 문서의 변경점과 새롭게 추가된 부분에 초점을 맞추어야 합니다.
<!-- -->
<!-- -->**형식(Format):**
<!-- -->- 익숙한 ASCII 문자만 사용합니다. 결과는 고정폭(monospaced) 폰트로 렌더링됩니다.  
<!-- -->- 문서의 **첫 줄과 마지막 줄에는 60개의 “_” 문자로 된 수평선**을 추가합니다.  
<!-- -->- 각 줄은 **최대 60자 이내**로 제한합니다.  
<!-- -->- 파일 관계를 설명할 필요가 있다면 디렉터리/계층 구조를 사용하고,  
<!-- -->  그렇지 않다면 흐름도(Flowchart) 또는 시각적인 형태로 표현합니다.  
<!-- -->- 문서나 내용이 제공되지 않았다면, 내용을 요청하세요.
<!-- -->
<!-- -->---
<!-- -->
<!-- -->## 리뷰어가 참고하면 좋은 링크 🔗  
<!-- -->- Jira url: [여기에 Jira URL 삽입]
<!-- -->
<!-- -->---
<!-- -->
<!-- -->## 먼저 읽기 좋은 진입점 🚘️  
<!-- -->*PR 세부 정보를 기반으로, 리뷰 시 가장 먼저 보면 좋은 주요 진입 파일(Controller, Consumer 등)을 나열하세요.*
<!-- -->
<!-- -->---
<!-- -->
<!-- -->## 리뷰어에게 🙏  
<!-- -->*PR의 복잡한 로직, 트레이드오프, 또는 집중해서 봐주었으면 하는 부분을 짧게 설명하세요.*  
<!-- -->너무 세부적이지 않게, 상위 레벨에서 작성합니다.
<!-- -->
<!-- -->---
<!-- -->
<!-- -->## 체크 리스트 ✅  
<!-- -->- [x] 테스트 코드를 작성했습니다. (코드 변경이 있는 경우)  
<!-- -->- [x] 커밋 전 SonarLint 분석을 수행했습니다.  
<!-- -->- [x] 셀프 리뷰를 진행했습니다.  
<!-- -->- [x] Jira 티켓을 업데이트했습니다.</code></div></pre></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"post34","lang":"ko","title":"AI 브라우저를 활용한 PR 메세지 자동화","date":"2025-12-14","section":"tech","tags":"AI","thumbnail":"https://i.imgur.com/iJY5NAV.png","preview":"\n개발자에게 \"코드 작성\"과 \"PR(Pull Request) 작성\" 중 무엇이 더 고통스러운지 묻는다면, 의외로 많은 분이 후자를 택합니다. 구현은 즐겁지만, 그것을 남에게 글로 설명하는데는 생각보다 상당한 시간이 소모되기 때문입니다.\n\n최근 Copi"},"detail":"\n개발자에게 \"코드 작성\"과 \"PR(Pull Request) 작성\" 중 무엇이 더 고통스러운지 묻는다면, 의외로 많은 분이 후자를 택합니다. 구현은 즐겁지만, 그것을 남에게 글로 설명하는데는 생각보다 상당한 시간이 소모되기 때문입니다.\n\n최근 Copilot이나 IntelliJ AI 등 다양한 도구가 등장하며 PR 작성을 돕고 있지만, 여전히 '2%' 부족함을 느낍니다. 오늘은 그 부족한 2%를 채우고, 리뷰어와 작성자 모두가 행복해지는 PR 자동화 워크플로우를 공유하고자 합니다.\n\n## 1. 좋은 Pull Request 란?\n\n기술적인 자동화를 논하기 전에, 우리가 작성해야 할 '좋은 PR'의 정의부터 명확히 해야 합니다.\n\n좋은 PR의 핵심은 **'리뷰어에 대한 공감'**입니다. 리뷰어는 바쁜 시간을 쪼개서 코드를 봅니다. 리뷰어의 시간을 아껴주고, 코드의 의도를 명확하게 전달하는것이 PR의 가장 중요한 목표입니다.\n\n### 좋은 PR의 구성요소\n\n1.  **명확한 맥락:** 단순히 코드가 '무엇'이 변했는지는 diff만 봐도 알 수 있습니다. 중요한 것은 **'왜 이 변경이 필요했는가'**입니다.\n\n2. **직관적 시각 자료:** 백 마디 말보다 한 장의 스크린샷이나 다이어그램이 훨씬 빠른 이해를 돕습니다.\n\n3. **작고 집중된 단위:** 하나의 PR은 하나의 이슈만 다루어야 리뷰와 병합의 리스크가 줄어듭니다.\n\n코드 리뷰를 하는 이유 중 하나는 팀원 간의 작업 방향 정렬과 개발 과정에서의 실수 방지입니다.\n\n작업 배경을 상세히 기술하면 리뷰어는 단순히 코드 변경사항만 보는 것이 아니라, 왜 이런 변경이 필요했는지 맥락을 이해할 수 있습니다. 이러한 컨텍스트 공유는 리뷰어가 더 넓은 시야에서 코드를 바라볼 수 있게 하여, 단순 문법적 오류나 컨벤션 위반을 넘어 아키텍처적 개선점, 잠재적 사이드 이펙트, 대안적 접근 방식 등 다양한 관점의 피드백을 제공할 수 있게 됩니다.\n\n결과적으로 배경 설명이 잘 된 PR은 리뷰의 질을 높이고, 팀 전체의 도메인 지식과 시스템 이해도를 향상시키는 효과적인 지식 공유의 수단이 됩니다.\n\n## 2. 현재 AI Assistant의 한계: '맥락'의 부재\n\n최근의 생성형 AI 도구들(GitHub Copilot, IntelliJ AI 등)은 코드 변경 사항(Diff)을 요약하는 데 탁월한 능력을 보여줍니다. 버튼 하나만 누르면 아래와 같은 요약을 순식간에 만들어냅니다.\n\n\u003e Copilot Agent가 생성한 PR\n\n\u003cimg src=\"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/nof7n7t65c4zkp49cpim.png\" alt=\"Copilot PR\" width=\"400\"\u003e\n\n그러나 AI가 만든 PR 메시지는 초안으로는 충분하지만, 작업의 배경까지는 담아내지 못해 코드 수정의 근본적인 이유를 파악하기 어렵다는 한계가 있습니다.\n\n* **배경 정보 누락:** AI는 코드 자체만 보고 요약하므로, \"사용자가 특정 상황에서 겪은 불편함\"이나 \"기획 의도\" 같은 외부 맥락을 알지 못합니다.\n\n* **근본적 이유 부재:** 코드를 '수정했다'는 사실은 알지만, '왜 수정해야만 했는지'에 대한 비즈니스적/기술적 배경은 설명하지 못합니다.\n\n결국, 리뷰어가 가장 궁금해하는 **'작업 배경'**을 채우는 일은 여전히 사람의 몫으로 남게 됩니다. 그리고 배경을 간결하고 핵심적으로 정리하는 것은 PR 작성에서 가장 많은 시간을 잡아먹습니다.\n\n이 과정을 AI가 대신할 수 있다면, 리뷰어에게 코드의 의도를 명확하게 전달하면서 PR 작성에 드는 시간을 크게 줄일 수 있을 것입니다.\n\n## 3. Jira 티켓에서 맥락 가져오기\n\n그렇다면 어디서 맥락을 가져올 수 있을까요? 저는 개발을 시작하기 전에 티켓에 해결하고자 하는 문제와 목표를 명확히 정의합니다.\n\n티켓에는 작업을 한눈에 파악할 수 있도록 \"무엇을\", \"왜\" 하는지를 간결하게 담습니다. 예를 들어 \"주문 취소 시 재고 복구 실패 이슈 수정\"처럼 핵심 문제와 해결 방향을 제목에서부터 드러냅니다.\n\n그 다음 작업의 배경과 목적을 상세히 기술합니다. 현재 어떤 문제가 발생하고 있는지(AS-IS), 왜 이 작업이 필요한지, 어떤 비즈니스 영향이 있는지를 구체적으로 작성하고, 작업을 통해 달성하고자 하는 상태(TO-BE)와 명확한 완료 기준을 함께 정의합니다.\n\n\"PR 쓰기도 귀찮은데 Jira까지 자세히 쓰라고요?\"라고 반문하실 수 있습니다. 하지만 **문제 정의는 AI가 아닌 사람이 해야 할 영역**입니다. 티켓을 충실히 작성하면 다음과 같은 이점이 있습니다.\n\n### 작업 전 Jira 티켓을 풍부하게 작성하면 좋은점\n\n1. **명확한 목표 설정과 작업 집중**: \"로그인 버그 수정\"이라는 한 줄짜리 티켓은 '어떤 상황에서', '어떤 사용자가', '어떻게' 버그를 겪는지 알려주지 않습니다. 상세한 설명, 재현 방법, 기대 결과가 담긴 티켓은 내가 무엇을 해야 하는지 명확히 알려주어 불필요한 고민 없이 작업에만 집중하게 해줍니다.\n\n2. **정확한 계획 수립과 예측 가능성 확보**: 티켓이 상세할수록 작업의 규모와 복잡도를 더 정확하게 예측할 수 있습니다.\n\n3. **미래의 나를 위한 기록**: 몇 달 뒤 내가 작성한 코드를 다시 보게 될 때, Jira 티켓은 \"내가 왜 이 코드를 이렇게 작성했더라?\"에 대한 완벽한 답변이 되어 줍니다. 유지보수와 기능 확장이 훨씬 쉬워집니다.\n\n## 4. AI 브라우저로 워크플로우 완성하기\n\n우리의 목표는 **\"PR 작성에 드는 시간과 노력을 최소화하면서, 퀄리티는 극대화하는 것\"**입니다. 이를 위해 AI 브라우저인 Commet(혹은 Dia)의 기능을 활용할 수 있습니다.\n\nCommet은 단순한 브라우징을 넘어, 사용자가 자주 사용하는 프롬프트를 **'Shotcuts'** 형태로 저장하고 `/Shotcuts`로 호출할 수 있는 기능을 제공합니다. 이를 통해 매번 긴 프롬프트를 작성할 필요 없이, Jira의 문맥과 코드 변경 사항을 결합할 수 있습니다.\n\n### 자동화 워크플로우\n\n1.  **Jira 티켓 작성:** 작업 전, 이슈의 배경(Why)과 해결 방안(What)을 Jira에 명확히 기록합니다.\n\n2. **Commet Shortcuts 등록:** Commet 브라우저에 PR 자동 생성을 위한 Shortcuts를 등록해줍니다.\n![shortcuts](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/n2mgw687c31cvmbf0t44.png)\n\n3. PR 수정 화면에서 Commet의 사이드 패널을 열고 미리 등록해 둔 **PR 작성 Shortcuts**을 호출\n합니다.\n\n이렇게 하면 AI는 Jira에서 **'작업의 의도(Why)'**를 가져오고, Git Diff에서 **'구현 내용(What)'**을 가져와 PR 메시지를 생성해 줍니다.\n\n## PR 자동 생성에 사용한 프롬프트\n\n마지막으로 PR 자동 생성에 사용한 프롬프트를 공유드리며 글을 마무리하도록 하겠습니다.\n\n```text\n당신은 명확하고 규칙적인 Pull Request 설명을 잘 작성하는 숙련된 소프트웨어 엔지니어입니다.  \n당신의 주요 목표는 주어진 Jira 티켓과 PR 세부 정보를 기반으로, 우리 팀의 컨벤션을 **엄격히 준수하는 PR 메시지**를 생성하는 것입니다.\n\n이 페이지의 브랜치 정보를 참고하고, “ABCD”로 시작하는 관련 Jira 티켓을 열어 그 안에 작성된 맥락(context)을 활용해 Pull Request 설명을 작성하세요.  \n아래 링크를 통해 Jira 보드에 접속한 뒤, 해당 DPDD 티켓을 검색하여 열 수 있습니다.\n\nJira 보드 링크:  \n`https://jiraboard.atlassian.net/jira/software/c/projects/DPDD/boards/5218?assignee=712020%3A8ef336bd-458e-4630-a79f-d0ea76930601`\n\nPR 메시지는 **한국어로 작성하세요.**\n\n---\n\n### 따라야 할 PR 메시지 템플릿\n\n## 요약 ✍️  \n*Jira 티켓과 PR 정보를 기반으로 간결한 요약을 작성하세요.*  \n먼저 이번 변경의 **배경과 목적(Why)** 을 설명하고,  \n그 다음 **구체적인 변경 내용(What, How)** 을 불릿 포인트로 정리하세요.\n\n이 문서에 포함된 클래스나 주요 구성요소 간의 관계, 역할, 상호작용을 설명하기 위해  \n`mermaid` 다이어그램을 코드 블록 안에 렌더링하세요.  \n다이어그램은 문서의 변경점과 새롭게 추가된 부분에 초점을 맞추어야 합니다.\n\n**형식(Format):**\n- 익숙한 ASCII 문자만 사용합니다. 결과는 고정폭(monospaced) 폰트로 렌더링됩니다.  \n- 문서의 **첫 줄과 마지막 줄에는 60개의 “_” 문자로 된 수평선**을 추가합니다.  \n- 각 줄은 **최대 60자 이내**로 제한합니다.  \n- 파일 관계를 설명할 필요가 있다면 디렉터리/계층 구조를 사용하고,  \n  그렇지 않다면 흐름도(Flowchart) 또는 시각적인 형태로 표현합니다.  \n- 문서나 내용이 제공되지 않았다면, 내용을 요청하세요.\n\n---\n\n## 리뷰어가 참고하면 좋은 링크 🔗  \n- Jira url: [여기에 Jira URL 삽입]\n\n---\n\n## 먼저 읽기 좋은 진입점 🚘️  \n*PR 세부 정보를 기반으로, 리뷰 시 가장 먼저 보면 좋은 주요 진입 파일(Controller, Consumer 등)을 나열하세요.*\n\n---\n\n## 리뷰어에게 🙏  \n*PR의 복잡한 로직, 트레이드오프, 또는 집중해서 봐주었으면 하는 부분을 짧게 설명하세요.*  \n너무 세부적이지 않게, 상위 레벨에서 작성합니다.\n\n---\n\n## 체크 리스트 ✅  \n- [x] 테스트 코드를 작성했습니다. (코드 변경이 있는 경우)  \n- [x] 커밋 전 SonarLint 분석을 수행했습니다.  \n- [x] 셀프 리뷰를 진행했습니다.  \n- [x] Jira 티켓을 업데이트했습니다.\n```\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8\u0026t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads \u0026 Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true},"page":"/[lang]/[id]","query":{"lang":"ko","id":"post34"},"buildId":"vjSj3GbVwS7vkZ0Aa3KlF","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>