<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)</title><meta name="title" content="PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)"/><meta property="og:url" content="https://headf1rst.github.io/log/ko/push-notification"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://www.pushengage.com/wp-content/uploads/2021/11/Best-FREE-Push-Notification-Services.png"/><meta property="og:description"/><link rel="alternate" hrefLang="ko" href="https://headf1rst.github.io/log/ko/push-notification"/><link rel="alternate" hrefLang="x-default" href="https://headf1rst.github.io/log/ko/push-notification"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)","datePublished":"2023-01-03 10:00","dateModified":"2023-01-03 10:00","author":{"@type":"Person","name":"Sanha Ko"},"description":"","image":"https://www.pushengage.com/wp-content/uploads/2021/11/Best-FREE-Push-Notification-Services.png","url":"https://headf1rst.github.io/TIL/ko/push-notification","keywords":"프로젝트","inLanguage":"ko-KR","publisher":{"@type":"Organization","name":"headF1rst","logo":{"@type":"ImageObject","url":"https://headf1rst.github.io/TIL/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://headf1rst.github.io/TIL/ko/push-notification"}}</script><meta name="next-head-count" content="25"/><link rel="preload" href="/log/_next/static/css/39f7a3d9bab3920f.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/39f7a3d9bab3920f.css" data-n-g=""/><link rel="preload" href="/log/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/log/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/log/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/log/_next/static/chunks/webpack-1b0decc0375da57b.js" defer=""></script><script src="/log/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/log/_next/static/chunks/main-6e6d6dc6617c8481.js" defer=""></script><script src="/log/_next/static/chunks/pages/_app-a194fea961ad530a.js" defer=""></script><script src="/log/_next/static/chunks/pages/%5Blang%5D/%5Bid%5D-0687c01bb97784d8.js" defer=""></script><script src="/log/_next/static/ONUWyZTcCL0KlNevGTiXH/_buildManifest.js" defer=""></script><script src="/log/_next/static/ONUWyZTcCL0KlNevGTiXH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/log/ko/"><div class="flex items-center gap-2 cursor-pointer"><h1 class="text-lg ">JustAnotherBlog</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden items-center"><a href="/log/ko/"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/log/ko/category/"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a><div class="relative"><button class="flex items-center gap-1 hover:text-indigo-300 text-base font-light">🇰🇷<!-- --> <!-- -->한국어</button></div></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2023-01-03 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">프로젝트</span></div></div><div class="flex items-center gap-2"><span class="text-sm text-gray-400">🇺🇸 영어로 읽기</span></div><div class="markdown-body" style="font-size:17px"><p>푸시 알림이란 사용자가 서비스를 사용하고 있지 않은 상황에서도 사용자에게 알림을 보내는 방법입니다.</p>
<p>푸시 알림을 구현하는 방법에는 <code node="[object Object]">Server-Sent Events (SSE)</code> 를 사용하는 방식과 <code node="[object Object]">Firebase Cloud Messaging (FCM)</code> 을 사용하는 방식이 있습니다.</p>
<p>두 방식 중 현재 요구사항에 더 적합한 방식은 무엇인지 알아보고, 이를 구현하여 편지가 도착했다는 알람을 받을 수 있도록 해보겠습니다.</p>
<h2>1. SSE vs FCM</h2>
<h3>SSE(Server Side Event)</h3>
<p>SSE는 실시간으로(real-time) 서버에서 클라이언트로 데이터를 전송하는 스트림 방식의 프로토콜이며 <strong>HTTP/2.0</strong>부터 추가되었습니다.</p>
<p>일반적인 HTTP 통신의 경우에는 클라이언트가 서버에 요청을 보내야만 서버에서 요청에 대한 응답을 보내줄 수 있습니다. 하지만 현재 구현하고자 하는 알림 시스템의
경우에는 클라이언트로부터 요청이 없더라도 서버에 편지가 도착했다는 이벤트가 발생했을 때 그에 대한 응답을 보내줘야만 합니다.</p>
<p>가장 단순한 방법으로는 주기적으로 서버에 편지 도착 여부를 묻는 HTTP 요청을 보내는 것입니다. 이를 <strong>Polling</strong>방식이라고 합니다. 하지만 이런 polling
방식의 경우, 일정한 텀을 두고 요청을 보내기 때문에 엄격히 말하면 실시간이라고 볼 수 없습니다. 또한 HTTP의 connectionless 한 성격 때문에 서버에 편지가 도착한
이벤트가 발생하지 않더라고 연결을 맺고 끊는 과정을 거치게 됩니다. 이를 개선한 방식으로 <strong>Long Polling</strong>방식이 있지만 HTTP connectionless 한
성격으로 인한 문제점은 그대로입니다.</p>
<p>다음으로 고려해볼 수 있는 방법이 바로 SSE 방식입니다. SSE 방식은 요청에 대한 응답 이후에 연결을 끊지 않고 유지하고 있다가 추가로
서버에서 이벤트가 발생했을 때 응답을 보내주는 방식입니다. 서버에서 클라이언트로 실시간으로 데이터를 보내주기 때문에 구현하고자 하는 편지 도착 알림과 같은 시나리오에 유용합니다.</p>
<h3>FCM(Firebase Cloud Messaging)</h3>
<p>반면 FCM은 안드로이드, iOS, 웹을 포함한 다양한 플랫폼의 사용자에게 메시지를 보낼 수 있는 더 완전한 기능의 크로스 플랫폼 메시징 솔루션입니다.
특정 장치 또는 주제(특정 주제에 가입된 장치 그룹)로 메시지를 보내는 기능을 포함하여 메시지를 전달하기 위한 다양한 옵션을 제공합니다.
FCM은 또한 우선순위가 높거나 낮은 메시지를 보내거나 오프라인 상태인 장치에 메시지를 보내고 다시 온라인 상태가 되면 메시지를 전송하는 등 다양한 전송 옵션을 지원합니다.</p>
<p>SSE는 구현이 간단하고 real-time 서비스이지만 몇 가지 제한이 존재합니다. SSE 통신 방식을 지원하지 않는 브라우저에서는 사용할 수 없으며 payload 크기가
제한적이기 때문에 알림에 많은 데이터를 담을 수 없으며 지원되지 않는 브라우저를 사용하는 사용자의 경우에는 중요한 알림을 아예 받지 못할 가능성이 존재했습니다.</p>
<p>반면 FCM의 경우, SSE에 비해서 별도의 설정이 추가로 필요하며 real-time 서비스이긴 하지만 장치 연결 상태, 메시지의 크기와 포맷, 그리고 네트워크 상태 등 전송 시간이 지연될 수 있는 요소들이 존재합니다.
하지만 심각한 지연이 발생하지는 않으며 SSE의 실시간성에 비해서 느린 편이기 때문에 연성 실시간(soft real-time) 시스템에 적합합니다.</p>
<h2>2. 현재 서비스에 더 적합한 쪽은?</h2>
<p>현재 구현하고자 하는 기능은 푸시 알림이며, 가능한 빨리 전달되어야 하지만 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방합니다. 또한 iOS, 안드로이드, 데스크톱을 지원해야 합니다.</p>
<p>이러한 요구사항을 종합해 보았을 때 다양한 플랫폼을 지원하며 연성 실시간 시스템이어도 문제가 없는 FCM을 사용하여 알림 기능을 구현하는 방향을 선택하였습니다.</p>
<h2>3. 푸시 알림을 위한 3가지 컴포넌트</h2>
<p><img src="https://i.imgur.com/aQq4OJ4.jpg" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<ul>
<li>
<p><strong>알림 제공자</strong></p>
<p>알림 요청(notification request)을 만들어 푸시 알림 서비스(FCM)로 보내주는 주체.</p>
<p>알림 요청을 만들기 위해서는 다음과 같은 데이터가 필요하다.</p>
<ul>
<li>단말 토큰 (device token)<!-- -->
<ul>
<li>알림 요청을 보내는 데 필요한 고유 식별자.</li>
</ul>
</li>
<li>페이로드 (payload)<!-- -->
<ul>
<li>알림 내용을 담은 JSON 딕셔너리</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>FCM</strong></p>
<ul>
<li>구글이 제공하는 원격 서비스. 푸시 알림을 다양한 플랫폼으로 보내는 역할을 담당</li>
</ul>
</li>
<li>
<p><strong>디바이스 장치</strong></p>
<ul>
<li>푸시 알림을 수신하는 사용자 단말</li>
</ul>
</li>
</ul>
<h2>4. FCM의 동작 원리</h2>
<p>알림 제공자가 알림 요청을 만들어 HTTP 통신을 통해 전송할 경우, 요청이 처리되는 과정을 그림으로 나타내보면 다음과 같습니다.</p>
<p><img src="https://i.imgur.com/EGJQ13w.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>1_ 알림 제공자(서비스 어플리케이션)는 FCM에 단말 토큰과 페이로드를 담아서 HTTP POST 요청을 보낸다.</p>
<p>2_ 요청을 받은 FCM은 요청을 통해 받은 정보의 이상 유무에 따라 알림 제공자에게 적절한 응답을 보낸다.</p>
<p>3_ FCM은 메시지 우선순위, 수신 단말과의 통신 가능 여부 등을 고려하여 메시지를 수신 단말에 보낸다.</p>
<p>4_ 수신 단말은 정보 이상 유무에 따라 FCM에 적절한 응답을 보낸다.</p>
<p>이전에 구현해보았던 이메일 인증 로직과 유사한 부분이 많아서 HTTP 요청을 <code node="[object Object]">비동기 방식</code>으로 처리해야겠다는 생각을 쉽게 떠올릴 수 있었습니다.</p>
<h3>4.1 Sync vs Async &amp; Blocking vs Non-Blocking</h3>
<p>병목 지점 없는 안정적인 푸시 알림을 구현하기 위해서는 동기와 비동기, Blocking과 Non-Blocking에 대한 개념을 이해해야 합니다. 자세한 내용은 <a href="https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0">블로킹 Vs. 논 블로킹, 동기 Vs. 비동기</a> 포스트를 참고해주세요.</p>
<p>요약하자면 다음과 같습니다.</p>
<ul>
<li>
<p><code node="[object Object]">동기 - 비동기</code>란 특정 주체가 호출되는 함수의 <strong>작업 완료 여부를 신경 쓰는지</strong>의 여부 차이다.</p>
</li>
<li>
<p><code node="[object Object]">Blocking - Nonblocking</code>이란 특정 주체가 <strong>함수를 호출할 때 제어권을 양도하는지</strong>의 여부 차이다.</p>
</li>
<li>
<p><strong>SyncExample.js</strong></p>
</li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-jsx" style="white-space:pre"><span style="color:#a626a4">function</span><span> a() {
</span><span>    let </span><span style="color:#a626a4">result</span><span> </span><span class="hljs-operator">=</span><span> b();
</span><span>    console.</span><span style="color:#c18401">log</span><span>(</span><span style="color:#a626a4">result</span><span>);
</span><span>    console.</span><span style="color:#c18401">log</span><span>(&quot;a finished&quot;);
</span>}
<!-- -->
<span></span><span style="color:#a626a4">function</span><span> b() {
</span><span>    </span><span style="color:#a626a4">return</span><span> </span><span style="color:#986801">11</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#a0a1a7;font-style:italic">/*
</span><span style="color:#a0a1a7;font-style:italic">실행 결과
</span><span style="color:#a0a1a7;font-style:italic">11
</span><span style="color:#a0a1a7;font-style:italic">a finished
</span><span style="color:#a0a1a7;font-style:italic">*/</span></code></div></pre>
<p>Synchronous(동기)란 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리하는 것을 의미합니다. a 함수가 b 함수를 호출했을 때, a 함수가 b 함수의 수행 결과 및 종료를 신경 쓰는 경우를 예로 들 수 있습니다. 일반적인 경우 blocking과 동일한 의미로 사용될 수 있습니다.</p>
<ul>
<li><strong>AsyncExample.js</strong></li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-jsx" style="white-space:pre"><span style="color:#a626a4">function</span><span> a() {
</span><span>    </span><span style="color:#a626a4">fetch</span><span>(url, options)
</span><span>      .</span><span style="color:#a626a4">then</span><span>(response </span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><span> console.</span><span style="color:#c18401">log</span><span>(&quot;response arrives&quot;))
</span><span>      .catch(error </span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><span> console.</span><span style="color:#c18401">log</span><span>(&quot;error thrown&quot;));
</span><span>    console.</span><span style="color:#c18401">log</span><span>(&quot;a is done&quot;);
</span>}
<!-- -->
<span></span><span style="color:#a0a1a7;font-style:italic">/*
</span><span style="color:#a0a1a7;font-style:italic">실행 결과
</span><span style="color:#a0a1a7;font-style:italic">a is done
</span><span style="color:#a0a1a7;font-style:italic">response arrives
</span><span style="color:#a0a1a7;font-style:italic">*/</span></code></div></pre>
<p>반면 Asynchronous(비동기)란 두 주체가 서로의 시작/종료 시간과는 관계없이 별도의 수행 시작/종료 시간을 가지고 있는 것을 의미합니다.
a 함수가 b 함수를 호출했을 때, 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경 쓰고 처리하는 경우를 예로 들 수 있습니다.
대게 결과를 돌려주었을 때 순서와 결과(처리)에 관심이 있는지 아닌지로 판단할 수 있습니다.</p>
<p><img src="https://i.imgur.com/Rjm9qEh.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>비동기를 사용하면 두 개의 요청을 동시에 보내기 때문에 더 빠른 응답 속도를 보여줄 수 있습니다. 또한 현재 스레드가 Blocking 되지 않고 다른 작업을 수행할 수 있기 때문에 더 적은 수의 리소스(스레드)로 더 많은 양의 요청을 처리할 수 있습니다.</p>
<h2>5. 알림 시스템 아키텍처</h2>
<p>알림 제공자 역할을 하는 별도의 인스턴스를 생성하여 어플리케이션 서버와 알림 서버를 분리해야 할지, 어플리케이션 서버에 알림 기능을 추가해야 할지 고민이 되었습니다.</p>
<p>푸시 알림 시스템이 대량의 요청을 처리할 것으로 예상되거나 높은 수준의 가용성이 필요한 경우, 효과적으로 작동하는 데 필요한 리소스와 용량을 확보하기 위해 다음과 같이 별도의 인스턴스를 사용하는 것이 유용할 수 있습니다.</p>
<p><img src="https://i.imgur.com/zBICeHZ.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>또한 별도의 인스턴스를 사용하면 푸시 알림 시스템에 대한 격리 및 제어 기능을 더 많이 제공할 수 있으므로 보안 및 규정 준수 목적에 유용할 수 있습니다.</p>
<p>반면, 푸시 알림 시스템의 workload가 크지 않은 경우 기존 응용프로그램과 동일한 인스턴스를 사용하는 것이 비용 측면에서 효율적일 수 있습니다. 이렇게 하면 관리 및 유지해야 하는 인스턴스 수를 줄일 수 있어 리소스를 절약하고 복잡성을 줄일 수 있습니다.</p>
<p>저희 서비스의 경우 사용자가 편지를 받는 경우에만 알림 요청이 발생하고 아직 사용자가 많지 않은 점, 그리고 비용적인 측면을 고려하여 기존 응용프로그램과 동일한 인스턴스를 사용하기로 결정하였습니다. (서비스가 대박이 나서 아키텍처 수정하는 날이 오면 좋겠습니다)</p>
<p><img src="https://i.imgur.com/eb0TAnG.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<h2>6. FCM을 Spring Boot 프로젝트에 적용하기</h2>
<p>먼저 FCM을 사용할 프로젝트에 <code node="[object Object]">firebase-admin</code> 의존성을 추가해주었습니다.</p>
<h3>6.1 의존성 추가</h3>
<ul>
<li><strong>build.gradle</strong></li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-bash" style="white-space:pre"><span>dependencies {
</span>	//FCM
<span>	implementation </span><span style="color:#50a14f">&#x27;com.google.firebase:firebase-admin:7.1.1&#x27;</span><span>
</span>}</code></div></pre>
<h3>6.2 Firebase 프로젝트, 비공개 키 생성</h3>
<p><a href="https://console.firebase.google.com/u/0/">Firebase 콘솔</a>에 접속하여 프로젝트를 생성하고, <code node="[object Object]">프로젝트 설정 → 서비스 계정 항목</code>에서 비공개 키를 생성하였습니다.</p>
<p><img src="https://i.imgur.com/A4pqklA.png" alt="Post image" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>json 파일로 생성된 <code node="[object Object]">admin sdk</code> 를 프로젝트의 resouces 디렉토리로 이동시켜 주었습니다. 비밀키 파일은 깃허브와 같은 공개된 장소에 올라가는게 안전하지 않기 때문에 .gitignore 목록에 추가한 다음 @Value를 사용하여 불러오도록 하였습니다.</p>
<p><code node="[object Object]">개요 → 앱 추가 → 웹 앱에 Firebase 추가</code>를 선택하고 스니펫을 복사하여 어플리케이션 HTML에 추가하였습니다.</p>
<ul>
<li><strong>templates/firebase-snippet.html</strong></li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-html" style="white-space:pre"><span class="hljs-tag">&lt;</span><span class="hljs-tag" style="color:#e45649">script</span><span class="hljs-tag"> </span><span class="hljs-tag" style="color:#986801">type</span><span class="hljs-tag">=</span><span class="hljs-tag" style="color:#50a14f">&quot;module&quot;</span><span class="hljs-tag">&gt;</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// Import the functions you need from the SDKs you need</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a626a4">import</span><span class="javascript"> { initializeApp } </span><span class="javascript" style="color:#a626a4">from</span><span class="javascript"> </span><span class="javascript" style="color:#50a14f">&quot;https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js&quot;</span><span class="javascript">;
</span><span class="javascript">    </span><span class="javascript" style="color:#a626a4">import</span><span class="javascript"> { getAnalytics } </span><span class="javascript" style="color:#a626a4">from</span><span class="javascript"> </span><span class="javascript" style="color:#50a14f">&quot;https://www.gstatic.com/firebasejs/9.15.0/firebase-analytics.js&quot;</span><span class="javascript">;
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// </span><span class="javascript" style="color:#a626a4;font-style:italic">TODO:</span><span class="javascript" style="color:#a0a1a7;font-style:italic"> Add SDKs for Firebase products that you want to use</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// https://firebase.google.com/docs/web/setup#available-libraries</span><span class="javascript">
</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// Your web app&#x27;s Firebase configuration</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// For Firebase JS SDK v7.20.0 and later, measurementId is optional</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a626a4">const</span><span class="javascript"> firebaseConfig = {
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">apiKey</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;AIzaSyAhGBd-3pzg1HzHvGJ6poVatZ9t4fcRC7g&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">authDomain</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;text-me-917f5.firebaseapp.com&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">projectId</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;text-me-917f5&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">storageBucket</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;text-me-917f5.appspot.com&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">messagingSenderId</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;357915322625&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">appId</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;1:357915322625:web:694139cec2a5c263b81300&quot;</span><span class="javascript">,
</span><span class="javascript">        </span><span class="javascript" style="color:#986801">measurementId</span><span class="javascript">: </span><span class="javascript" style="color:#50a14f">&quot;G-WXZEPBL34M&quot;</span><span class="javascript">
</span><span class="javascript">    };
</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a0a1a7;font-style:italic">// Initialize Firebase</span><span class="javascript">
</span><span class="javascript">    </span><span class="javascript" style="color:#a626a4">const</span><span class="javascript"> app = initializeApp(firebaseConfig);
</span><span class="javascript">    </span><span class="javascript" style="color:#a626a4">const</span><span class="javascript"> analytics = getAnalytics(app);
</span><span class="javascript"></span><span class="hljs-tag">&lt;/</span><span class="hljs-tag" style="color:#e45649">script</span><span class="hljs-tag">&gt;</span></code></div></pre>
<h3>6.3 FCM 초기화</h3>
<p>어플리케이션이 실행되는 시점에 비공개 키 파일의 인증정보를 이용해 FirebaseApp을 초기화하는 객체를 구현해주었습니다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#4078f2">@Slf4j</span><span>
</span><span></span><span style="color:#4078f2">@Component</span><span>
</span><span></span><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">FCMInitializer</span><span class="hljs-class"> </span><span>{
</span>
<span>    </span><span style="color:#4078f2">@Value(&quot;${fcm.certification}&quot;)</span><span>
</span><span>    </span><span style="color:#a626a4">private</span><span> String googleApplicationCredentials;
</span>
<span>    </span><span style="color:#4078f2">@PostConstruct</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">initialize</span><span class="hljs-function hljs-params">()</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">throws</span><span class="hljs-function"> IOException </span><span>{
</span><span>        ClassPathResource resource = </span><span style="color:#a626a4">new</span><span> ClassPathResource(googleApplicationCredentials);
</span>
<span>        </span><span style="color:#a626a4">try</span><span> (InputStream is = resource.getInputStream()) {
</span>            FirebaseOptions options = FirebaseOptions.builder()
<!-- -->                    .setCredentials(GoogleCredentials.fromStream(is))
<!-- -->                    .build();
<!-- -->
<span>            </span><span style="color:#a626a4">if</span><span> (FirebaseApp.getApps().isEmpty()) {
</span>                FirebaseApp.initializeApp(options);
<span>                log.info(</span><span style="color:#50a14f">&quot;FirebaseApp initialization complete&quot;</span><span>);
</span>            }
<!-- -->        }
<!-- -->    }
<!-- -->}
</code></div></pre>
<p>빈 객체가 생성되고 의존성 주입이 완료된 후에 초기화가 실행될 수 있도록 @PostConstruct 설정을 해주었습니다.</p>
<h3>6.4 토큰 관리 저장소</h3>
<p>로그인 시에 클라이언트는 FCM 토큰(단말 토큰)을 서버에 전달하게 되는데 서버는 해당 토큰을 스토리지에 저장한 다음, 활성 토큰의 목록을 유지해야 합니다. FCM 공식 문서에 있는 <a href="https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko">토큰 관리 Best practice</a>에 따르면 토큰의 신선도 보장을 위해서 2개월 이상 사용되지 않은 토큰은 삭제하는 것을 권장하고 있습니다.</p>
<p>처음에는 현재 사용하고 있는 RDS의 유저 테이블에 FCM 토큰 필드를 추가하는 방식을 고려하였습니다. 하지만 토큰 갱신 및 삭제 연산이 빈번하게 발생하고 토큰의 데이터가 key-value 형태라는 점, 그리고 타임 스탬프를 통해서 토큰의 신선도를 관리해줘야 하는 요구사항에 더 적합한 스토리지가 <code node="[object Object]">Redis</code>라고 생각되었기 때문에 Redis를 토큰 관리 저장소로 선택하게 되었습니다.</p>
<p>Redis 설치방법과 Config 파일 작성에 대한 내용은 다루지 않고 넘어가도록 하겠습니다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#4078f2">@Repository</span><span>
</span><span></span><span style="color:#4078f2">@RequiredArgsConstructor</span><span>
</span><span></span><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">FCMTokenDao</span><span class="hljs-class"> </span><span>{
</span>
<span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> StringRedisTemplate tokenRedisTemplate;
</span>
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">saveToken</span><span class="hljs-function hljs-params">(LoginRequest loginRequest)</span><span class="hljs-function"> </span><span>{
</span>        tokenRedisTemplate.opsForValue()
<!-- -->                .set(loginRequest.getEmail(), loginRequest.getToken());
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> String </span><span class="hljs-function" style="color:#4078f2">getToken</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> tokenRedisTemplate.opsForValue().get(email);
</span>    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">deleteToken</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span>        tokenRedisTemplate.delete(email);
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">boolean</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">hasKey</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> tokenRedisTemplate.hasKey(email);
</span>    }
<!-- -->}
</code></div></pre>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#4078f2">@RestController</span><span>
</span><span></span><span style="color:#4078f2">@RequestMapping(&quot;/users&quot;)</span><span>
</span><span></span><span style="color:#4078f2">@RequiredArgsConstructor</span><span>
</span><span></span><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">UserController</span><span class="hljs-class"> </span><span>{
</span>
<span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> UserService userService;
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> FCMService fcmService;
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> AesUtils aesUtils;
</span>
<span>    </span><span style="color:#4078f2">@PostMapping(&quot;/login&quot;)</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> ResponseEntity&lt;LoginResponse&gt; </span><span class="hljs-function" style="color:#4078f2">login</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#4078f2">@RequestBody</span><span class="hljs-function hljs-params"> </span><span class="hljs-function hljs-params" style="color:#4078f2">@Valid</span><span class="hljs-function hljs-params"> </span><span class="hljs-function hljs-params" style="color:#a626a4">final</span><span class="hljs-function hljs-params"> LoginRequest request)</span><span class="hljs-function"> </span><span>{
</span>        LoginResponse loginResponse = userService.login(request);
<!-- -->        fcmService.saveToken(request);
<span>        </span><span style="color:#a626a4">return</span><span> ResponseEntity.ok().body(loginResponse);
</span>    }
<!-- -->
<span>    </span><span style="color:#4078f2">@DeleteMapping(&quot;/logout&quot;)</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">logout</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#4078f2">@JwtAuth</span><span class="hljs-function hljs-params"> String email)</span><span class="hljs-function"> </span><span>{
</span>        fcmService.deleteToken(email);
<!-- -->    }
<span>    </span><span style="color:#a0a1a7;font-style:italic">//...</span><span>
</span>}
</code></div></pre>
<h3>6.5 편지 전송 시 편지 수신 유저에게 알림 전송하기</h3>
<p>FCMService를 구현하기에 앞서 NotificationService 인터페이스를 구현하여 상속받도록 해주었는데 그 이유는 FCM뿐만 아니라 iOS 푸시 알림을 위한 APNs도 사용해야 하기 때문입니다. (iOS 웹 푸시는 현재 지원되지 않기 때문에 apple wallet을 통한 편법을 사용해야 합니다.)</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#4078f2">@Service</span><span>
</span><span></span><span style="color:#4078f2">@RequiredArgsConstructor</span><span>
</span><span></span><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">FCMService</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#a626a4">implements</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">NotificationService</span><span class="hljs-class"> </span><span>{
</span>
<span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> FCMTokenDao fcmTokenDao;
</span>
<span>    </span><span style="color:#4078f2">@Override</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">sendLetterReceivedNotification</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">if</span><span> (!hasKey(email)) {
</span><span>            </span><span style="color:#a626a4">return</span><span>;
</span>        }
<!-- -->        String token = getToken(email);
<!-- -->        Message message = Message.builder()
<span>                .putData(</span><span style="color:#50a14f">&quot;title&quot;</span><span>, </span><span style="color:#50a14f">&quot;편지 도착 알림&quot;</span><span>)
</span><span>                .putData(</span><span style="color:#50a14f">&quot;content&quot;</span><span>, </span><span style="color:#50a14f">&quot;편지가 도착했습니다.&quot;</span><span>)
</span>                .setToken(token)
<!-- -->                .build();
<!-- -->        send(message);
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">saveToken</span><span class="hljs-function hljs-params">(LoginRequest loginRequest)</span><span class="hljs-function"> </span><span>{
</span>        fcmTokenDao.saveToken(loginRequest);
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">deleteToken</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span>        fcmTokenDao.deleteToken(email);
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">private</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">send</span><span class="hljs-function hljs-params">(Message message)</span><span class="hljs-function"> </span><span>{
</span>        FirebaseMessaging.getInstance().sendAsync(message);
<!-- -->    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">private</span><span class="hljs-function"> String </span><span class="hljs-function" style="color:#4078f2">getToken</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> fcmTokenDao.getToken(email);
</span>    }
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">private</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">boolean</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">hasKey</span><span class="hljs-function hljs-params">(String email)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> fcmTokenDao.hasKey(email);
</span>    }
<!-- -->}
</code></div></pre>
<p>fcm 서버로 메시지를 전송할 때, 서버가 메시지의 응답을 기다리는 동안 블로킹으로 인한 성능 저하를 방지하고자 <code node="[object Object]">sendAsync()</code> 를 사용하여 메시지를 비동기적으로 처리하였습니다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#4078f2">@Service</span><span>
</span><span></span><span style="color:#4078f2">@Transactional(readOnly = true)</span><span>
</span><span></span><span style="color:#4078f2">@RequiredArgsConstructor</span><span>
</span><span></span><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">LetterService</span><span class="hljs-class"> </span><span>{
</span>    
<span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> UserRepository userRepository;
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> LetterRepository letterRepository;
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> FCMService fcmService;
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">final</span><span> AesUtils aesUtils;
</span>
<span>    </span><span style="color:#4078f2">@Transactional</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> LetterResponse </span><span class="hljs-function" style="color:#4078f2">makeLetter</span><span class="hljs-function hljs-params">(LetterRequest request)</span><span class="hljs-function"> </span><span>{
</span>        String decryptedId = aesUtils.decryption(request.getReceiverId());
<!-- -->        Long userId = Long.valueOf(decryptedId);
<span>        User receiver = userRepository.findById(userId).orElseThrow(UserNotFoundException::</span><span style="color:#a626a4">new</span><span>);
</span>        Letter letter = Letter.of(receiver, request.getSenderName(), request.getContents(), request.getImageUrl());
<!-- -->        letterRepository.save(letter);
<!-- -->        fcmService.sendLetterReceivedNotification(receiver.getEmail());
<span>        </span><span style="color:#a626a4">return</span><span> </span><span style="color:#a626a4">new</span><span> LetterResponse(letter.getId(), receiver.getName(),
</span>                request.getSenderName(), request.getContents(), request.getImageUrl());
<!-- -->    }
<span>    </span><span style="color:#a0a1a7;font-style:italic">//...</span><span>
</span>}</code></div></pre>
<h2>7. 마치며</h2>
<p>지금까지 FCM을 사용한 푸시 알림을 구현해 보았습니다. 알림 기능을 구현하면서 많은 기술적 고민을 하였고 대안을 검토해 보았습니다. 저의 얕은 지식으로 현시점에 가장 좋은 옵션을 고려해보았는데, 다양한 의견들을 댓글을 통해서 공유해주시면 감사하겠습니다.</p>
<hr/>
<p><strong>참고 자료</strong> 📚</p>
<ul>
<li>
<p><a href="https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko">FCM 등록 토큰 관리 모범 사례 | Firebase Cloud Messaging</a></p>
</li>
<li>
<p><a href="https://seungwoolog.tistory.com/88">[Firebase] FCM을 도입할 때 고려할 것들</a></p>
</li>
<li>
<p><a href="https://gilssang97.tistory.com/69">알림 기능을 구현해보자 - SSE(Server-Sent-Events)!</a></p>
</li>
<li>
<p><a href="https://velog.io/@skygl/FCM-Spring-Boot%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9B%B9-%ED%91%B8%EC%8B%9C-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0">FCM, Spring Boot를 사용하여 웹 푸시 기능 구현하기</a></p>
</li>
<li>
<p><a href="https://kerobero.tistory.com/38">Spring Boot 프로젝트에서 FCM을 이용한 웹 푸시 구현하기</a></p>
</li>
</ul></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"push-notification","lang":"ko","title":"PWA 환경에서 푸시 알림 구현하기 (Spring Boot, FCM, Redis)","category":null,"thumbnail":"https://www.pushengage.com/wp-content/uploads/2021/11/Best-FREE-Push-Notification-Services.png","tags":"프로젝트","date":"2023-01-03 10:00","preview":"\n푸시 알림이란 사용자가 서비스를 사용하고 있지 않은 상황에서도 사용자에게 알림을 보내는 방법입니다.\n\n푸시 알림을 구현하는 방법에는 `Server-Sent Events (SSE)` 를 사용하는 방식과 `Firebase Cloud Messaging ("},"detail":"\n푸시 알림이란 사용자가 서비스를 사용하고 있지 않은 상황에서도 사용자에게 알림을 보내는 방법입니다.\n\n푸시 알림을 구현하는 방법에는 `Server-Sent Events (SSE)` 를 사용하는 방식과 `Firebase Cloud Messaging (FCM)` 을 사용하는 방식이 있습니다.\n\n두 방식 중 현재 요구사항에 더 적합한 방식은 무엇인지 알아보고, 이를 구현하여 편지가 도착했다는 알람을 받을 수 있도록 해보겠습니다.\n\n## 1. SSE vs FCM\n\n### SSE(Server Side Event)\nSSE는 실시간으로(real-time) 서버에서 클라이언트로 데이터를 전송하는 스트림 방식의 프로토콜이며 **HTTP/2.0**부터 추가되었습니다.\n\n일반적인 HTTP 통신의 경우에는 클라이언트가 서버에 요청을 보내야만 서버에서 요청에 대한 응답을 보내줄 수 있습니다. 하지만 현재 구현하고자 하는 알림 시스템의\n경우에는 클라이언트로부터 요청이 없더라도 서버에 편지가 도착했다는 이벤트가 발생했을 때 그에 대한 응답을 보내줘야만 합니다.\n\n가장 단순한 방법으로는 주기적으로 서버에 편지 도착 여부를 묻는 HTTP 요청을 보내는 것입니다. 이를 **Polling**방식이라고 합니다. 하지만 이런 polling\n방식의 경우, 일정한 텀을 두고 요청을 보내기 때문에 엄격히 말하면 실시간이라고 볼 수 없습니다. 또한 HTTP의 connectionless 한 성격 때문에 서버에 편지가 도착한\n이벤트가 발생하지 않더라고 연결을 맺고 끊는 과정을 거치게 됩니다. 이를 개선한 방식으로 **Long Polling**방식이 있지만 HTTP connectionless 한\n성격으로 인한 문제점은 그대로입니다.\n\n다음으로 고려해볼 수 있는 방법이 바로 SSE 방식입니다. SSE 방식은 요청에 대한 응답 이후에 연결을 끊지 않고 유지하고 있다가 추가로\n서버에서 이벤트가 발생했을 때 응답을 보내주는 방식입니다. 서버에서 클라이언트로 실시간으로 데이터를 보내주기 때문에 구현하고자 하는 편지 도착 알림과 같은 시나리오에 유용합니다.\n\n### FCM(Firebase Cloud Messaging)\n\n반면 FCM은 안드로이드, iOS, 웹을 포함한 다양한 플랫폼의 사용자에게 메시지를 보낼 수 있는 더 완전한 기능의 크로스 플랫폼 메시징 솔루션입니다.\n특정 장치 또는 주제(특정 주제에 가입된 장치 그룹)로 메시지를 보내는 기능을 포함하여 메시지를 전달하기 위한 다양한 옵션을 제공합니다.\nFCM은 또한 우선순위가 높거나 낮은 메시지를 보내거나 오프라인 상태인 장치에 메시지를 보내고 다시 온라인 상태가 되면 메시지를 전송하는 등 다양한 전송 옵션을 지원합니다.\n\nSSE는 구현이 간단하고 real-time 서비스이지만 몇 가지 제한이 존재합니다. SSE 통신 방식을 지원하지 않는 브라우저에서는 사용할 수 없으며 payload 크기가\n제한적이기 때문에 알림에 많은 데이터를 담을 수 없으며 지원되지 않는 브라우저를 사용하는 사용자의 경우에는 중요한 알림을 아예 받지 못할 가능성이 존재했습니다.\n\n반면 FCM의 경우, SSE에 비해서 별도의 설정이 추가로 필요하며 real-time 서비스이긴 하지만 장치 연결 상태, 메시지의 크기와 포맷, 그리고 네트워크 상태 등 전송 시간이 지연될 수 있는 요소들이 존재합니다.\n하지만 심각한 지연이 발생하지는 않으며 SSE의 실시간성에 비해서 느린 편이기 때문에 연성 실시간(soft real-time) 시스템에 적합합니다.\n\n## 2. 현재 서비스에 더 적합한 쪽은?\n\n현재 구현하고자 하는 기능은 푸시 알림이며, 가능한 빨리 전달되어야 하지만 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방합니다. 또한 iOS, 안드로이드, 데스크톱을 지원해야 합니다. \n\n이러한 요구사항을 종합해 보았을 때 다양한 플랫폼을 지원하며 연성 실시간 시스템이어도 문제가 없는 FCM을 사용하여 알림 기능을 구현하는 방향을 선택하였습니다. \n\n## 3. 푸시 알림을 위한 3가지 컴포넌트\n\n![IMG_68FC117D3621-1.jpeg](https://i.imgur.com/aQq4OJ4.jpg)\n\n- **알림 제공자**\n    \n    알림 요청(notification request)을 만들어 푸시 알림 서비스(FCM)로 보내주는 주체.\n    \n    알림 요청을 만들기 위해서는 다음과 같은 데이터가 필요하다.\n    \n    - 단말 토큰 (device token)\n        - 알림 요청을 보내는 데 필요한 고유 식별자.\n    - 페이로드 (payload)\n        - 알림 내용을 담은 JSON 딕셔너리\n- **FCM**\n    - 구글이 제공하는 원격 서비스. 푸시 알림을 다양한 플랫폼으로 보내는 역할을 담당\n- **디바이스 장치**\n    - 푸시 알림을 수신하는 사용자 단말\n\n## 4. FCM의 동작 원리\n\n알림 제공자가 알림 요청을 만들어 HTTP 통신을 통해 전송할 경우, 요청이 처리되는 과정을 그림으로 나타내보면 다음과 같습니다.\n\n![스크린샷 2023-01-06 오후 12.35.19.png](https://i.imgur.com/EGJQ13w.png)\n\n1_ 알림 제공자(서비스 어플리케이션)는 FCM에 단말 토큰과 페이로드를 담아서 HTTP POST 요청을 보낸다.\n\n2_ 요청을 받은 FCM은 요청을 통해 받은 정보의 이상 유무에 따라 알림 제공자에게 적절한 응답을 보낸다. \n\n3_ FCM은 메시지 우선순위, 수신 단말과의 통신 가능 여부 등을 고려하여 메시지를 수신 단말에 보낸다.\n\n4_ 수신 단말은 정보 이상 유무에 따라 FCM에 적절한 응답을 보낸다.\n\n이전에 구현해보았던 이메일 인증 로직과 유사한 부분이 많아서 HTTP 요청을 `비동기 방식`으로 처리해야겠다는 생각을 쉽게 떠올릴 수 있었습니다.\n\n### 4.1 Sync vs Async \u0026 Blocking vs Non-Blocking\n\n병목 지점 없는 안정적인 푸시 알림을 구현하기 위해서는 동기와 비동기, Blocking과 Non-Blocking에 대한 개념을 이해해야 합니다. 자세한 내용은 [블로킹 Vs. 논 블로킹, 동기 Vs. 비동기](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0) 포스트를 참고해주세요.\n\n요약하자면 다음과 같습니다.\n\n- `동기 - 비동기`란 특정 주체가 호출되는 함수의 **작업 완료 여부를 신경 쓰는지**의 여부 차이다.\n- `Blocking - Nonblocking`이란 특정 주체가 **함수를 호출할 때 제어권을 양도하는지**의 여부 차이다.\n\n\n- **SyncExample.js**\n\n```jsx\nfunction a() {\n    let result = b();\n    console.log(result);\n    console.log(\"a finished\");\n}\n\nfunction b() {\n    return 11;\n}\n\n/*\n실행 결과\n11\na finished\n*/\n```\n\nSynchronous(동기)란 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리하는 것을 의미합니다. a 함수가 b 함수를 호출했을 때, a 함수가 b 함수의 수행 결과 및 종료를 신경 쓰는 경우를 예로 들 수 있습니다. 일반적인 경우 blocking과 동일한 의미로 사용될 수 있습니다.\n\n- **AsyncExample.js**\n\n```jsx\nfunction a() {\n    fetch(url, options)\n      .then(response =\u003e console.log(\"response arrives\"))\n      .catch(error =\u003e console.log(\"error thrown\"));\n    console.log(\"a is done\");\n}\n\n/*\n실행 결과\na is done\nresponse arrives\n*/\n```\n\n반면 Asynchronous(비동기)란 두 주체가 서로의 시작/종료 시간과는 관계없이 별도의 수행 시작/종료 시간을 가지고 있는 것을 의미합니다. \na 함수가 b 함수를 호출했을 때, 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 직접 신경 쓰고 처리하는 경우를 예로 들 수 있습니다. \n대게 결과를 돌려주었을 때 순서와 결과(처리)에 관심이 있는지 아닌지로 판단할 수 있습니다.\n\n![Untitled](https://i.imgur.com/Rjm9qEh.png)\n\n비동기를 사용하면 두 개의 요청을 동시에 보내기 때문에 더 빠른 응답 속도를 보여줄 수 있습니다. 또한 현재 스레드가 Blocking 되지 않고 다른 작업을 수행할 수 있기 때문에 더 적은 수의 리소스(스레드)로 더 많은 양의 요청을 처리할 수 있습니다.\n    \n## 5. 알림 시스템 아키텍처\n\n알림 제공자 역할을 하는 별도의 인스턴스를 생성하여 어플리케이션 서버와 알림 서버를 분리해야 할지, 어플리케이션 서버에 알림 기능을 추가해야 할지 고민이 되었습니다.\n\n푸시 알림 시스템이 대량의 요청을 처리할 것으로 예상되거나 높은 수준의 가용성이 필요한 경우, 효과적으로 작동하는 데 필요한 리소스와 용량을 확보하기 위해 다음과 같이 별도의 인스턴스를 사용하는 것이 유용할 수 있습니다. \n\n![스크린샷 2023-01-02 오후 10.44.34.png](https://i.imgur.com/zBICeHZ.png)\n\n또한 별도의 인스턴스를 사용하면 푸시 알림 시스템에 대한 격리 및 제어 기능을 더 많이 제공할 수 있으므로 보안 및 규정 준수 목적에 유용할 수 있습니다.\n\n반면, 푸시 알림 시스템의 workload가 크지 않은 경우 기존 응용프로그램과 동일한 인스턴스를 사용하는 것이 비용 측면에서 효율적일 수 있습니다. 이렇게 하면 관리 및 유지해야 하는 인스턴스 수를 줄일 수 있어 리소스를 절약하고 복잡성을 줄일 수 있습니다.\n\n저희 서비스의 경우 사용자가 편지를 받는 경우에만 알림 요청이 발생하고 아직 사용자가 많지 않은 점, 그리고 비용적인 측면을 고려하여 기존 응용프로그램과 동일한 인스턴스를 사용하기로 결정하였습니다. (서비스가 대박이 나서 아키텍처 수정하는 날이 오면 좋겠습니다)\n\n![스크린샷 2023-01-02 오후 10.45.48.png](https://i.imgur.com/eb0TAnG.png)\n\n## 6. FCM을 Spring Boot 프로젝트에 적용하기\n\n먼저 FCM을 사용할 프로젝트에 `firebase-admin` 의존성을 추가해주었습니다.\n\n### 6.1 의존성 추가\n\n- **build.gradle**\n\n```bash\ndependencies {\n\t//FCM\n\timplementation 'com.google.firebase:firebase-admin:7.1.1'\n}\n```\n\n### 6.2 Firebase 프로젝트, 비공개 키 생성\n\n[Firebase 콘솔](https://console.firebase.google.com/u/0/)에 접속하여 프로젝트를 생성하고, `프로젝트 설정 → 서비스 계정 항목`에서 비공개 키를 생성하였습니다.\n\n![스크린샷 2023-01-02 오후 11.54.08.png](https://i.imgur.com/A4pqklA.png)\n\njson 파일로 생성된 `admin sdk` 를 프로젝트의 resouces 디렉토리로 이동시켜 주었습니다. 비밀키 파일은 깃허브와 같은 공개된 장소에 올라가는게 안전하지 않기 때문에 .gitignore 목록에 추가한 다음 @Value를 사용하여 불러오도록 하였습니다.\n\n`개요 → 앱 추가 → 웹 앱에 Firebase 추가`를 선택하고 스니펫을 복사하여 어플리케이션 HTML에 추가하였습니다.\n\n- **templates/firebase-snippet.html**\n\n```html\n\u003cscript type=\"module\"\u003e\n    // Import the functions you need from the SDKs you need\n    import { initializeApp } from \"https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js\";\n    import { getAnalytics } from \"https://www.gstatic.com/firebasejs/9.15.0/firebase-analytics.js\";\n    // TODO: Add SDKs for Firebase products that you want to use\n    // https://firebase.google.com/docs/web/setup#available-libraries\n\n    // Your web app's Firebase configuration\n    // For Firebase JS SDK v7.20.0 and later, measurementId is optional\n    const firebaseConfig = {\n        apiKey: \"AIzaSyAhGBd-3pzg1HzHvGJ6poVatZ9t4fcRC7g\",\n        authDomain: \"text-me-917f5.firebaseapp.com\",\n        projectId: \"text-me-917f5\",\n        storageBucket: \"text-me-917f5.appspot.com\",\n        messagingSenderId: \"357915322625\",\n        appId: \"1:357915322625:web:694139cec2a5c263b81300\",\n        measurementId: \"G-WXZEPBL34M\"\n    };\n\n    // Initialize Firebase\n    const app = initializeApp(firebaseConfig);\n    const analytics = getAnalytics(app);\n\u003c/script\u003e\n```\n\n### 6.3 FCM 초기화\n\n어플리케이션이 실행되는 시점에 비공개 키 파일의 인증정보를 이용해 FirebaseApp을 초기화하는 객체를 구현해주었습니다.\n\n```java\n@Slf4j\n@Component\npublic class FCMInitializer {\n\n    @Value(\"${fcm.certification}\")\n    private String googleApplicationCredentials;\n\n    @PostConstruct\n    public void initialize() throws IOException {\n        ClassPathResource resource = new ClassPathResource(googleApplicationCredentials);\n\n        try (InputStream is = resource.getInputStream()) {\n            FirebaseOptions options = FirebaseOptions.builder()\n                    .setCredentials(GoogleCredentials.fromStream(is))\n                    .build();\n\n            if (FirebaseApp.getApps().isEmpty()) {\n                FirebaseApp.initializeApp(options);\n                log.info(\"FirebaseApp initialization complete\");\n            }\n        }\n    }\n}\n\n```\n \n\n빈 객체가 생성되고 의존성 주입이 완료된 후에 초기화가 실행될 수 있도록 @PostConstruct 설정을 해주었습니다.\n\n### 6.4 토큰 관리 저장소\n\n로그인 시에 클라이언트는 FCM 토큰(단말 토큰)을 서버에 전달하게 되는데 서버는 해당 토큰을 스토리지에 저장한 다음, 활성 토큰의 목록을 유지해야 합니다. FCM 공식 문서에 있는 [토큰 관리 Best practice](https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko)에 따르면 토큰의 신선도 보장을 위해서 2개월 이상 사용되지 않은 토큰은 삭제하는 것을 권장하고 있습니다.\n\n처음에는 현재 사용하고 있는 RDS의 유저 테이블에 FCM 토큰 필드를 추가하는 방식을 고려하였습니다. 하지만 토큰 갱신 및 삭제 연산이 빈번하게 발생하고 토큰의 데이터가 key-value 형태라는 점, 그리고 타임 스탬프를 통해서 토큰의 신선도를 관리해줘야 하는 요구사항에 더 적합한 스토리지가 `Redis`라고 생각되었기 때문에 Redis를 토큰 관리 저장소로 선택하게 되었습니다.\n\nRedis 설치방법과 Config 파일 작성에 대한 내용은 다루지 않고 넘어가도록 하겠습니다.\n\n```java\n@Repository\n@RequiredArgsConstructor\npublic class FCMTokenDao {\n\n    private final StringRedisTemplate tokenRedisTemplate;\n\n    public void saveToken(LoginRequest loginRequest) {\n        tokenRedisTemplate.opsForValue()\n                .set(loginRequest.getEmail(), loginRequest.getToken());\n    }\n\n    public String getToken(String email) {\n        return tokenRedisTemplate.opsForValue().get(email);\n    }\n\n    public void deleteToken(String email) {\n        tokenRedisTemplate.delete(email);\n    }\n\n    public boolean hasKey(String email) {\n        return tokenRedisTemplate.hasKey(email);\n    }\n}\n\n```\n\n```java\n@RestController\n@RequestMapping(\"/users\")\n@RequiredArgsConstructor\npublic class UserController {\n\n    private final UserService userService;\n    private final FCMService fcmService;\n    private final AesUtils aesUtils;\n\n    @PostMapping(\"/login\")\n    public ResponseEntity\u003cLoginResponse\u003e login(@RequestBody @Valid final LoginRequest request) {\n        LoginResponse loginResponse = userService.login(request);\n        fcmService.saveToken(request);\n        return ResponseEntity.ok().body(loginResponse);\n    }\n\n    @DeleteMapping(\"/logout\")\n    public void logout(@JwtAuth String email) {\n        fcmService.deleteToken(email);\n    }\n    //...\n}\n\n```\n### 6.5 편지 전송 시 편지 수신 유저에게 알림 전송하기\n\nFCMService를 구현하기에 앞서 NotificationService 인터페이스를 구현하여 상속받도록 해주었는데 그 이유는 FCM뿐만 아니라 iOS 푸시 알림을 위한 APNs도 사용해야 하기 때문입니다. (iOS 웹 푸시는 현재 지원되지 않기 때문에 apple wallet을 통한 편법을 사용해야 합니다.)\n\n```java\n@Service\n@RequiredArgsConstructor\npublic class FCMService implements NotificationService {\n\n    private final FCMTokenDao fcmTokenDao;\n\n    @Override\n    public void sendLetterReceivedNotification(String email) {\n        if (!hasKey(email)) {\n            return;\n        }\n        String token = getToken(email);\n        Message message = Message.builder()\n                .putData(\"title\", \"편지 도착 알림\")\n                .putData(\"content\", \"편지가 도착했습니다.\")\n                .setToken(token)\n                .build();\n        send(message);\n    }\n\n    public void saveToken(LoginRequest loginRequest) {\n        fcmTokenDao.saveToken(loginRequest);\n    }\n\n    public void deleteToken(String email) {\n        fcmTokenDao.deleteToken(email);\n    }\n\n    private void send(Message message) {\n        FirebaseMessaging.getInstance().sendAsync(message);\n    }\n\n    private String getToken(String email) {\n        return fcmTokenDao.getToken(email);\n    }\n\n    private boolean hasKey(String email) {\n        return fcmTokenDao.hasKey(email);\n    }\n}\n\n```\n\nfcm 서버로 메시지를 전송할 때, 서버가 메시지의 응답을 기다리는 동안 블로킹으로 인한 성능 저하를 방지하고자 `sendAsync()` 를 사용하여 메시지를 비동기적으로 처리하였습니다.\n\n```java\n@Service\n@Transactional(readOnly = true)\n@RequiredArgsConstructor\npublic class LetterService {\n    \n    private final UserRepository userRepository;\n    private final LetterRepository letterRepository;\n    private final FCMService fcmService;\n    private final AesUtils aesUtils;\n\n    @Transactional\n    public LetterResponse makeLetter(LetterRequest request) {\n        String decryptedId = aesUtils.decryption(request.getReceiverId());\n        Long userId = Long.valueOf(decryptedId);\n        User receiver = userRepository.findById(userId).orElseThrow(UserNotFoundException::new);\n        Letter letter = Letter.of(receiver, request.getSenderName(), request.getContents(), request.getImageUrl());\n        letterRepository.save(letter);\n        fcmService.sendLetterReceivedNotification(receiver.getEmail());\n        return new LetterResponse(letter.getId(), receiver.getName(),\n                request.getSenderName(), request.getContents(), request.getImageUrl());\n    }\n    //...\n}\n```\n\n## 7. 마치며\n\n지금까지 FCM을 사용한 푸시 알림을 구현해 보았습니다. 알림 기능을 구현하면서 많은 기술적 고민을 하였고 대안을 검토해 보았습니다. 저의 얕은 지식으로 현시점에 가장 좋은 옵션을 고려해보았는데, 다양한 의견들을 댓글을 통해서 공유해주시면 감사하겠습니다. \n\n---\n\n**참고 자료** 📚\n\n- [FCM 등록 토큰 관리 모범 사례 | Firebase Cloud Messaging](https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko)\n\n- [[Firebase] FCM을 도입할 때 고려할 것들](https://seungwoolog.tistory.com/88)\n\n- [알림 기능을 구현해보자 - SSE(Server-Sent-Events)!](https://gilssang97.tistory.com/69)\n\n- [FCM, Spring Boot를 사용하여 웹 푸시 기능 구현하기](https://velog.io/@skygl/FCM-Spring-Boot%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9B%B9-%ED%91%B8%EC%8B%9C-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)\n\n- [Spring Boot 프로젝트에서 FCM을 이용한 웹 푸시 구현하기](https://kerobero.tistory.com/38)\n","lang":"ko","allPostsInOtherLang":[]},"__N_SSG":true},"page":"/[lang]/[id]","query":{"lang":"ko","id":"push-notification"},"buildId":"ONUWyZTcCL0KlNevGTiXH","assetPrefix":"/log","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>