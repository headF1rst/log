{"pageProps":{"postData":{"id":"post6","lang":"ko","title":"[오브젝트] 3장 - 역할, 책임, 협력","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-09-05 10:00","preview":"\n- 객체지향의 본질 : 협력하는 객체들의 공동체를 창조하는 것\n    - 기능 구현을 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할, 책임이 필요한지 파악\n\n- 객체들은 메시지를 주고 받으며 협력한다\n\n- `협력`\n    - 어플리케이션 기능 구"},"detail":"\n- 객체지향의 본질 : 협력하는 객체들의 공동체를 창조하는 것\n    - 기능 구현을 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할, 책임이 필요한지 파악\n\n- 객체들은 메시지를 주고 받으며 협력한다\n\n- `협력`\n    - 어플리케이션 기능 구현을 위한 객체들의 상호작용\n    - 다른 객체에 무엇인가를 **요청**하는 것\n- `책임`\n    - 협력에 참여하기 위해 객체가 수행하는 로직\n- `역할`\n    - 협력안에서 수행하는 책임이 모여 객체가 수행하는 역할을 구성\n\n## 협력 - 객체 설계를 위한 문맥 제공\n\n객체지향 시스템 - `자율적`인 객체들의 `공동체`\n객체는 고립된 존재가 아닌 협력하는 사회적 존재\n\n- 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 `위임` 하거나 서로 `협력`한다.\n    - 객체는 메시지를 통해서 협력한다\n    - 메시지를 수신한 객체는 `메서드`를 실행해 요청에 응답\n        - 객체는 수신받은 메시지를 처리할 방법을 **스스로** 선택한다\n            - 객체는 자율적인 존재\n            - 객체 내부 구현 (상태, 행동)을 캡슐화 하여 자율성을 확보\n\n### 객체 설계시 상태와 행동을 결정하는 기준\n\n객체가 참여하고 있는 협력에 따라 객체의 `상태` 와 `행동`이 정해진다.\n\n메세지 처리 가능 여부로 협력이 결정 -> 협력이 객체의 행동을 결정 -> 행동이 객체의 상태를 결정\n\n객체의 상태는 그 객체의 행동에 필요한 정보가 무엇인지로 결정된다.\n\n## 책임\n\n- `책임`\n    - 협력에 참여하기 위해 객체가 수행하는 행동\n    - 하는 것과 아는 것, 두 가지 범주\n    - `하는 것`\n        - 객체 생성 및 계산 수행 등 스스로 하는것\n        - 다른 객체의 행동을 시작하는 것\n        - 다른 객체의 활동을 제어, 조절하는 것\n    - `아는 것`\n        - 사적인 정보를 아는것\n        - 관련된 객체를 아는것\n        - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것\n\n책임을 할당하기 위해서는 협력을 정의해야한다.\n협력을 설계하기 위해서는 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는것에서 시작.\n\n- 시스템은 사용자에게 제공해야 하는 `기능`인 시스템 책임을 파악\n- 시스템 책임을 더 작은 책임으로 분할\n- 분할된 책임을 수행할 수 있는 적절한 객체 (역할)을 찾아 책임 할당\n- 해당 객체에 책임 할당하여 두 객체가 협력하도록 한다.\n\n객체가 책임을 수행하게 하는 방법 : 메시지를 전송하는 것\n책임을 할당하는 것 = 메시지의 이름을 결정하는 것\n\n### 메시지가 객체를 결정\n\n- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별\n- 메시지를 처리할 객체를 선택\n\n1. 객체가 최소한의 인터페이스를 가질 수 있게 된다\n2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다\n    - 인터페이스는 무엇을 하는지는 표현하지만 어떻게 수행하는지는 노출하면 안된다.\n\n### 행동이 상태를 결정\n\n협력에 필요한 객체의 행동을 결정하고 나서 상태를 결정\n협력 관계 속에서 다른 객체에게 무엇을 제공하고 무엇을 얻어야 할지를 고민하라\n\n## 역할을 통해 유연하고 재사용 가능한 협력을 얻는다\n\n- `역할`\n    - 다른 것으로 교체할 수 있는 책임의 집합\n    - 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯\n    - 구체적인 객체들의 타입을 캡슐화하는 추상화\n    - 역할을 구현하는 방법\n        - 추상 클래스\n        - 인터페이스\n\n- 협력에 적합한 책임을 수행하는 대상이\n    - 한 종류라면 - 객체\n    - 여러 종류의 객체들이 참여할 수 있다면 - 역할\n\n역할 덕분에 설계의 구성 요소를 추상화 할 수 있다\n\n### 느낀점\n\n이번장을 읽으면서, 머리로는 이해한 객체 설계 기법을 어떻게 하면 프로젝트에 적용해 볼 수 있을까 하는 고민을 해보았습니다.\n\n개인적으로 TDD가 모듈간의 의존도를 낮추고 객체지향적으로 프로그램을 설계하는데 도움을 줄 수 있지 않을까 생각해보았습니다.\n\nTDD를 기반으로 한다면 의존관계가 높은 테스트 코드 자체를 만들기가 어렵기 때문에 하나의 큰 기능을 작은 단위의 기능으로 쪼게게 됩니다.\n\n또한 자연스럽게 테스트를 통과하기 위한 메서드를 만든 다음, 메서드를 위한 필드값을 정의하는 순서로 구현이 이루어지기 때문에 행동이 상태를 결정하는 구조로 설계가 이루어 집니다.\n\n이러한 이유에서 TDD는 테스트 기법이 아닌 설계 기법이라 하지 않을까 생각해보게 되었습니다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}