{"pageProps":{"postData":{"id":"post18","lang":"ko","title":"JPA 트랜잭션과 영속성 컨텍스트","section":"tech","thumbnail":"https://images.velog.io/images/dnjscksdn98/post/14072bd8-850b-4d2b-8476-cb5385bbcd36/jpa.png","tags":"JPA","date":"2024-01-07 10:00","searchKeywords":"jpa, entitymanager, 영속성 컨텍스트, 트랜잭션","description":"JPA 트랜잭션과 영속성 컨텍스트","preview":"\n최근 구현한 테스트 코드에서 `@Transactional` 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.\n\n타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로"},"detail":"\n최근 구현한 테스트 코드에서 `@Transactional` 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.\n\n타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로직에 대한 테스트 코드였는데 당시 상황을 간단하게 재현해 보았다.\n\n```kotlin\n@Entity  \n@Table(name = \"orders\")  \nclass Order (  \n    val shippingLabel: String,  \n    var parcelStatus: Boolean = true,  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    val id: Long? = null,  \n) {  \n    fun isParcelRegister(): Boolean {  \n        return parcelStatus  \n    }  \n  \n    fun updateParcelStatus(registerSuccess: Boolean) {  \n        parcelStatus = registerSuccess  \n    }  \n}\n```\n\n```kotlin\n@Service  \nclass OrderStatusService(  \n    private val orderRepository: OrderRepository,  \n) {  \n    \n    @Transactional  \n    fun checkOrderSubmissionStatus(message: OutSourcingResultMessage) {  \n        val order = orderRepository.findByShippingLabel(message.shippingLabel)  \n        order.updateParcelStatus(message.registerSuccess)  \n    }  \n}\n```\n\n```kotlin\n@SpringBootTest  \nclass OrderStatusChangeServiceTest @Autowired constructor(  \n    private val orderStatusService: OrderStatusService,  \n    private val orderRepository: OrderRepository,  \n) {  \n  \n    @Test  \n    @DisplayName(\"송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.\")  \n    fun checkOrderSubmissionStatusTest() {  \n        val order = Order(shippingLabel = \"12345\")  \n        val savedOrder = orderRepository.save(order)  \n        val failureMessage = OutSourcingResultMessage(  \n            shippingLabel = savedOrder.shippingLabel,  \n            registerSuccess = false  \n        )  \n  \n        orderStatusService.checkOrderSubmissionStatus(failureMessage)  \n  \n        order.isParcelRegister() shouldBe false  \n    }  \n}\n```\n\nOrderStatusChangeService의 checkOrderSubmissionStatus(failureMessage) 메서드에 `@Transactional`이 걸려있고 order의 `parcelStatus`를 true에서 **false**로 변경한다.\n\n이때 JPA 더티 체킹을 활용하여 데이터베이스 컬럼값을 변경하기 때문에 checkOrderSubmissionStatus 메서드가 종료되는 시점에 checkOrderSubmissionstatus의 트랜잭션이 커밋 되면서 영속성 컨텍스트의 변경 사항이 데이터베이스로 flush 될 것이기 때문에 테스트는 성공할 것이라 예상된다.\n\n하지만 테스트 실행 결과, 테스트가 실패한 것을 확인할 수 있었다.\n\n![[스크린샷 2024-01-06 오후 9.20.22.png]](https://i.imgur.com/lTvSdwQ.png)\n\n이때 checkOrderSubmissionStatus를 호출하는 테스트 코드에 `@Transactional`을 걸어주면 테스트는 성공한다.\n\n왜 테스트 코드의 `@Transactional` 여부에 따라서 테스트 결과가 달라지는 것일까?\n## 테스트 코드의 엔티티는 영속성 컨텍스트에 관리되지 않는다\n\n스프링 컨테이너는 기본적으로 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다.\n\n즉, 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 같다는 뜻으로 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션 커밋 시점에 영속성 컨텍스트를 flush하고 종료한다.\n\n```kotlin\n@SpringBootTest  \nclass OrderStatusChangeServiceTest @Autowired constructor(  \n    private val orderStatusService: OrderStatusService,  \n    private val orderRepository: OrderRepository,  \n    private val entityManager: EntityManager,  \n) {  \n  \n    @Test  \n    @DisplayName(\"송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.\")  \n    fun checkOrderSubmissionStatusTest() {  \n        val order = Order(shippingLabel = \"12345\")  \n        val savedOrder = orderRepository.save(order)  \n        val failureMessage = OutSourcingResultMessage(  \n            shippingLabel = savedOrder.shippingLabel,  \n            registerSuccess = false  \n        )  \n  \n        println(entityManager.contains(savedOrder)) // false  \n        orderStatusService.checkOrderSubmissionStatus(failureMessage)  \n  \n        order.isParcelRegister() shouldBe false  \n    }  \n}\n```\n\n위의 결과에서 볼 수 있듯 테스트 코드의 엔티티는 트랜잭션 범위 밖이기 때문에 영속성 컨텍스트에 등록이 되어있지 않다. `checkOrderSubmissionStatus` 메서드 내에서 조회해 온 Order는 트랜잭션 범위이기 때문에 영속성 컨텍스트에 의해 관리되고 있지만 테스트 코드에서 검증의 대상이 되는 Order는 트랜잭션 범위 밖에서 조회된, **영속성 컨텍스트에 의해 관리되지 않는** Order를 대상으로 데이터 변경 **검증이 이루어진다**.\n\n때문에 실제 데이터베이스의 컬럼값은 의도한 대로 true에서 false로 변경되었지만, 테스트 코드의 Order는\n영속성 컨텍스트의 1차 캐시에 관리되지 않기 때문에 당연하게도 더티 체킹의 효과를 볼 수 없는 것이다.\n\n테스트 코드에 `@Transactional`을 붙여준다면 테스트 코드의 엔티티가 영속성 컨텍스트에 의해 관리되게 되고 1차 캐시에 의해 더티 체킹 대상이 되기 때문에 테스트가 성공하게 된다.\n## JpaTransactionManager는 트랜잭션 단위로 EntityManager를 관리한다\n\n위 사례를 통해서 더티 체킹은 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용되며, 영속성 컨텍스트는 트랜잭션 단위로 생성, 삭제된다는 것을 알 수 있었다.\n\nJPA가 트랜잭션 단위로 영속성 컨텍스트를 생성, 관리하는 부분의 코드를 한번 살펴보았다.\n\n먼저 스프링의 표준 트랙잭션 워크플로우를 구현하는 `AbstractPlatformTransactionManager` 클래스를 살펴보면 `startTransaction()` 메서드에서 \n`TransactionManager`의 `doBegin()` 메서드를 호출하는것을 볼 수 있다.\n\n![[스크린샷 2024-01-07 오후 6.59.49.png]](https://i.imgur.com/l4sY5Fz.png)\n\n`doBegin()` 메서드는 `TransactionManager`를 구현하는 `JpaTransactionManager`에서 확인할 수 있다.\n\n![[스크린샷 2024-01-07 오후 7.26.00.png]](https://i.imgur.com/7Qm3pOV.png)\n\n이때  새로 시작된 트랜잭션이라면 EntityManager를 생성하고 `JpaTransactionObject`에 저장한다.\n\n`JpaTransactionObject`는 현재 트랜잭션의 상태를 추적하는 데 사용되며, 트랜잭션 범위 내에서 사용되는 EntityManager를 `EntityManagerHolder`를 통해서 관리하고 있다.\n\n이러한 로직을 통해서 트랜잭션 범위 내에서 동일한 EntityManager가 사용될 수 있던 것이다.\n\n## 마무리\n\n지금까지 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 어떻게 관리되는지 알아보았다.\n\n사실 영속성 컨텍스트의 생존 범위가 항상 트랜잭션 범위내인 것은 아니다.\nOSIV(Open Session In View)를 사용하면 영속성 컨텍스트의 범위를 트랜잭션 범위 밖까지 확장 할 수 있다.","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}