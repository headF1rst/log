{"pageProps":{"postData":{"id":"post30","lang":"ko","title":"Gson 라이브러리 InaccessibleObjectException","thumbnail":"https://media.techmaster.vn/api/static/bq0a8rs51co78aldi4p0/lsRpW5hr","section":"tech","tags":"gson, Java","date":"2024-07-02 10:00","searchKeywords":"gson, java","description":"gson","preview":"\nSpring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보"},"detail":"\nSpring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보고자 한다.\n\n## Gson 라이브러리 란?\n\n구글이 만든 자바 기반 라이브러리로, 자바 객체를 JSON으로 직렬화(Serialization)하거나 JSON을 자바 객체로 역직렬화(Deserialization)하는 작업을 쉽게 할 수 있도록 도와준다.\n\n### 직렬화 과정 내부 동작\n\n`Gson.toJson(Object)` 메서드는 객체를 전달받아, 인자로 전달된 객체를 Json으로 변환하여 반환한다.\n\n```java\nGson gson = new Gson();\nString json = gson.toJson(myObject);\n```\n\n`toJson(Object src)` 메서드는 내부적으로 객체의 타입을 추론한 후 `toJson(Object src, Type typeOfSrc, Appendable writer)` 메서드를 호출한다.\n\n호출된 `toJson` 메서드는 주어진 객체 타입에 맞는 `TypeAdapter`를 찾고, 이를 사용하여 객체를 JSON으로 변환한다. 이때 객체 타입에 맞는 TypeAdapter를 찾기 위해 `getAdapter(TypeToken)` 메서드를 호출한다.\n\n```java\npublic void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {  \n    TypeAdapter<Object> adapter = (TypeAdapter<Object>) getAdapter(TypeToken.get(typeOfSrc));\n    // ...\n}\n```\n\n`getAdapter(TypeToken)` 메서드는 주어진 타입에 대한 `TypeAdapter`를 먼저 캐시에서 찾고, 없으면 `TypeAdapterFactory` 리스트를 순회하면서 각 팩토리에 대해 `create` 메서드를 호출하여 주어진 타입에 대한 `TypeAdapter`를 생성할 수 있는지 확인한다.\n\n```java\npublic <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {  \n  TypeAdapter<?> cached = typeTokenCache.get(type);  \n  if (cached != null) {  \n    TypeAdapter<T> adapter = (TypeAdapter<T>) cached;  \n    return adapter;  \n  }  \n\n  // ...\n  \n  TypeAdapter<T> candidate = null;  \n  try {  \n    FutureTypeAdapter<T> call = new FutureTypeAdapter<>();  \n    threadCalls.put(type, call);  \n  \n    for (TypeAdapterFactory factory : factories) {  \n      candidate = factory.create(this, type);  \n      if (candidate != null) {  \n        call.setDelegate(candidate);  \n        // Replace future adapter with actual adapter  \n        threadCalls.put(type, candidate);  \n        break;  \n      }  \n    }  \n  } \n  // ...\n  return candidate;  \n}\n```\n\nTypeAdapterFactory 리스트를 순회하면서, 먼저 사용자 정의 또는 특수한 TypeAdapterFactory를 확인하고, 적절한 TypeAdapter를 찾지 못하면 **ReflectiveTypeAdapterFactory**를 사용하여 객체의 필드에 접근하고 JSON으로 직렬화 한다.\n\n## 문제 원인\n\n> Unable to make field private final java.time.LocalDate java.time.LocalDateTime.date accessible: module java.base does not \"opens java.time\" to unnamed module.\n\n로그인 시에 `ValidToken` 객체를 직렬화하여 Redis에 저장하는 과정에서 Gson 라이브러리를 사용하는데, 위와 같은 예외가 발생했다.\n\nSpring Boot 3.2.x로 버전업하면서 Java 버전 또한 11에서 17로 업그레이드 하였다.\nJava 17 이상 부터는 모듈화된 애플리케이션에서 리플렉션을 통해 다른 모듈의 private 필드에 접근하는 것이 제한되도록 변경 되었기 때문에, Gson 라이브러리를 사용하여 TypeAdapterFactory 리스트를 순회하는 과정에서 문제가 발생하는것 이었다.\n\nGson은 먼저 사용자 정의 또는 특수한 `TypeAdapterFactory`를 확인하고, 적절한 `TypeAdapter`를 찾지 못하면 `ReflectiveTypeAdapterFactory`를 사용하게 된다.\n\n`ReflectiveTypeAdapterFactory`는 객체의 필드를 탐색하고, `field.setAccessible(true)`를 호출하여 private 필드를 접근 가능하도록 설정한다. 하지만 Java 17 이상의 모듈 시스템에서는 모듈화된 \n애플리케이션에서 이러한 호출이 기본적으로 제한되기 때문에 `ReflectiveTypeAdapterFactory`가 private 필드에 접근할 수 없게 되어, 결과적으로 직렬화 및 역직렬화 과정에서 예외가 발생하게 되는 것이다.\n\n## 해결방법\n\nprivate 필드를 가진 클래스 타입에 대한 직렬화 및 역직렬화 로직이 구현된 커스텀 TypeAdapter를 구현한면 Gson이 TypeAdapterFactory 리스트를 순회할 때, 정의한 커스텀 TypeAdapter가 ReflectiveTypeAdapterFactory 보다 우선순위를 갖기 때문에 문제를 해결할 수 있다.\n\n```java\npublic class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {\n\n    private static final DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n\n    @Override\n    public void write(JsonWriter jsonWriter, LocalDateTime localDateTime) throws IOException {\n        jsonWriter.value(localDateTime.format(formatter));\n    }\n\n    @Override\n    public LocalDateTime read(JsonReader jsonReader) throws IOException {\n        return LocalDateTime.parse(jsonReader.nextString(), formatter);\n    }\n}\n```\n\n## 참고 자료\n- [Error reflection JDK 17 and gson](https://github.com/google/gson/issues/1979)\n- [Gson 공식 트러블 슈팅 가이드 문서](https://github.com/google/gson/blob/main/Troubleshooting.md#reflection-inaccessible)\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}