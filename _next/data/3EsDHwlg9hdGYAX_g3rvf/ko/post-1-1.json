{"pageProps":{"postData":{"id":"post-1-1","lang":"ko","title":"if-else, switch 성능 비교 (feat. JMH)","category":"JAVA","thumbnail":"https://www.bachelorprint.com/wp-content/uploads/2023/07/Lab-report-Definition.jpg","tags":"Java","date":"2023-12-24 10:00","searchKeywords":"자바, jmh, if, switch","description":"if-else, switch 성능 비교","preview":"\n최근에 회사 팀원분의 추천으로 ['크리에이티브 프로그래머'](https://m.yes24.com/Goods/Detail/121961076)라는 책을 읽어보았는데, 비판적 사고에 대한 중요성을 강조하고 있다.\n\n비판적 사고란 정보를 받아들일 때 단순히"},"detail":"\n최근에 회사 팀원분의 추천으로 ['크리에이티브 프로그래머'](https://m.yes24.com/Goods/Detail/121961076)라는 책을 읽어보았는데, 비판적 사고에 대한 중요성을 강조하고 있다.\n\n비판적 사고란 정보를 받아들일 때 단순히 수용하지 않고, 의심하고 분석하는 과정을 말한다. \n보통 새로운 기술을 강의나 책을 통해서 배울 때면, 두 기술을 단순 비교하고 상황에 따라서 적합한 기술은 무엇인지 알려주는 경우가 많은데, \n유명한 책에서 그렇다니까 '왜'라는 질문 없이 그렇구나 넘어가고는 했다.\n\n지금부터라도 그냥 넘어갔던, 어쩌면 당연하다고 생각했던 것들에 대해서 의심해 보고 직접 확인해 보는 시간을 가져보고자 한다. \n가장 먼저 자바를 처음 배웠을 때 무심코 넘어갔던 if-else 문과 switch 문의 성능 차이에 대해서 알아보도록 하자.\n\n## if-else, switch 바이트코드 분석\n\n간단한 분기 문을 if-else 문과 switch 문으로 작성하였으며 1, 3, 5에 해당하는 case 값을 설정하였다.\n\n```java\npublic int ifElseStatement() {\n    int temp = 0;\n    int num = generateRandomIntFromOneToTen();\n\n    if (num == 1) {\n        temp = 1;\n    } else if (num == 3) {\n        temp = 3;\n    } else if (num == 5) {\n        temp = 5;\n    } else {\n        temp = 99;\n    }\n    return temp;\n}\n```\n\n```java\npublic int switchStatement() {\n    int temp = 0;\n    int num = generateRandomIntFromOneToTen();\n\n    switch (num) {\n        case 1:\n            temp = 1;\n            break;\n        case 3:\n            temp = 3;\n            break;\n        case 5:\n            temp = 5;\n            break;\n        default:\n            temp = 99;\n    }\n\n    return temp;\n}\n```\n\n작성한 두 분기 문이 내부적으로 어떻게 동작하는지 자바 바이트코드를 통해 분석해 보았다.\n\n```java\npublic ifElseStatement()I \n        ICONST_0 \n        ISTORE 1\n        ALOAD 0\n        GETFIELD example/IfElseVSSwitchTest.num : Ljava/lang/Integer;\n        INVOKEVIRTUAL java/lang/Integer.intValue ()I\n        ICONST_1\n        IF_ICMPNE L6\n        ICONST_1\n        ISTORE 1\n        GOTO L8\n\n        //...\n\n        L9\n        ALOAD 0\n        GETFIELD example/IfElseVSSwitchTest.num : Ljava/lang/Integer;\n        INVOKEVIRTUAL java/lang/Integer.intValue ()I\n        ICONST_3\n        IF_ICMPNE L8\n        ICONST_3\n        ISTORE 1\n        L8\n        ICONST_4\n        ISTORE 1\n        ILOAD 1\n        IRETURN\n```\n\nif-else 문은 연속된 if와 else if 문을 통해 **차례대로** 조건을 확인한다.\n바이트코드에서는 이를 `IF_ICMPNE` 명령어를 통해 구현하였으며 두 값을 비교하고 결과에 따라 분기하고 있다.\n\n```java\npublic switchStatement()I\n        L0\n        LINENUMBER 43 L0\n        ICONST_0\n        ISTORE 1\n        L1\n        LINENUMBER 46 L1\n        ALOAD 0\n        INVOKEVIRTUAL example/IfElseVSSwitchTest.generateRandomIntFromOneToTen ()V\n        L2\n        LINENUMBER 48 L2\n        ALOAD 0\n        GETFIELD example/IfElseVSSwitchTest.num : Ljava/lang/Integer;\n        INVOKEVIRTUAL java/lang/Integer.intValue ()I\n        TABLESWITCH\n        1: L3\n        2: L4\n        3: L5\n        4: L4\n        5: L6\n        default: L4\n        L3\n        LINENUMBER 50 L3\n        FRAME SAME\n        ICONST_1\n        ISTORE 1\n        GOTO L7\n        L5\n        LINENUMBER 53 L5\n        FRAME SAME\n        ICONST_2\n        ISTORE 1\n        GOTO L7\n        L6\n        LINENUMBER 56 L6\n        FRAME SAME\n        ICONST_\n        ISTORE 1\n        GOTO L7\n        L4\n        LINENUMBER 59 L4\n        FRAME SAME\n        BIPUSH 99\n        ISTORE 1\n        L7\n        LINENUMBER 63 L7\n        FRAME SAME\n        ILOAD 1\n        IRETURN\n        L8\n        LOCALVARIABLE this Lexample/IfElseVSSwitchTest; L0 L8 0LOCALVARIABLE temp I L1 L8 1\n        MAXSTACK = 2\n        MAXLOCALS = 2\n```\n\nswitch 문의 바이트코드를 보면 `TableSwitch`라는게 보인다.\n\n`TableSwitch`는 정숫값에에 기반한 switch 문에 사용되며, TableSwitch 뒤에 나오는 `1: L3`, `3: L5`, `5: L6`는 각 case에 대한 정보를 나타낸다.\n\n예를 들어, `1: L3`는 `num`이 1일 경우 `L3` 레이블로 점프하라는 의미이며 `default: L9` 또한 `num`이 1, 3, 5중 어느 값도 아니라면 \n`L9` 라벨로 점프하라는 의미이다.\n\n`L3`, `L5`, `L6` 라벨들은 각각의 case에 대한 코드 블록을 나타내며 정수 1을 스택에 푸시하고, 스택의 최상윗값을 `temp` 변수에 저장하는 것을 나타낸다. \n그다음 `GOTO L7`에서 제어를 `L7` 레이블로 이동시킨다.\n\n그런데 한 가지 이상한 부분이 있다.\n\n우리는 1, 3, 5에 해당하는 case만 줬지만 case들 사이의 값인 2,4 또한 default에 해당하는 control flow를 따르도록 컴파일된 것을 확인할 수 있다.\n\n이는 `TABLESWITCH`의 특징으로, `TABLESWITCH`는 case 범위 내 모든 값을 인덱싱하여 `jump table`을 구성하고, 해당하는 인덱스의 실행 지점으로 바로 점프한다. \n\n별도의 비교 연산 없이 바로 이동할 수 있기 때문에 `TABLESWITCH`를 활용한 switch문은 O(1)시간이 소요된다.\n\n하지만 `TABLESWITCH`가 모든 상황에 적합한 건 아니다.\n\n`TABLESWITCH`는 case의 모든 범위를 인덱싱하기 때문에 case의 수가 적더라도 각 case의 범위가 넓다면 (1, 10, 100) 1 ~ 100까지의 정수를 모두 인덱싱하게 되어 과도한 jump table 생성 비용과 공간 비용이 발생한다.\n\n이러한 비용을 줄이기 위해서 컴파일러는 case의 범위가 넓은 경우에 `LOOKUPTABLE` 방식을 선택하여 switch 문을 구현한다.\n\n```java\nLOOKUPSWITCH\n        1: L3\n        10: L4\n        100: L5\ndefault: L6\n```\n\n위의 바이트코드에서 볼 수 있듯, `LOOKUPTABLE`은 case값  만으로 테이블을 구성한다.\n\n인덱스를 이용해 바로 찾아가는게 아니기 때문에 `LOOKUPTABLE`은 비교대상변수와 table에 구성된 key와의 비교연산이 필요한데, \n시간적 비용을 보완하고자 key들을 정렬하여 구성해놓고 이진탐색을 적용하여 O(logN) 시간을 보장하게 된다.\n\n결론적으로 `if-else`문은 분기 개수(N)에 따라 최악의 경우 O(N)이 소요되며, `switch`문은 분기 개수(N)에 따라 최악의 경우에도 O(logN) 시간이 \n수행된다는 것을 알 수 있었다.\n\n이제 분석을 넘어서 실제로 switch문이 if-else문보다 더 나은 처리 속도를 보여주는지 검증해보도록 하자.\n\n## 성능 비교\n\n둘의 성능을 비교 측정하기위해 `JMH`를 사용하였으며 다음과 같은 시나리오에서 테스트를 진행해보았다.\n\n```bash\njmh {  \n    threads = 1  \n    fork = 1  \n    warmupIterations = 1  \n    iterations = 1  \n}\n```\n\n- if-else와 switch문 (`TABLESWITCH`)의 성능차이\n- if-else와 switch문 (`LOOKUPTABLE`)의 성능차이\n\n## if-else와 switch문 (TABLESWITCH)의 성능차이\n\n```java\n@State(Scope.Benchmark)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\npublic class IfElseVSSwitchTest {\n\n    private Integer num;\n\n    @Setup\n    public void generateRandomIntFromOneToTen() {\n        Random random = new Random();\n        this.num = random.nextInt(10) + 1;\n    }\n\n    @Benchmark\n    public int ifElseStatement() {\n        int temp = 0;\n\n        for (int i = 0; i < 5_000; ++i) {\n            generateRandomIntFromOneToTen();\n\n            if (num == 1) {\n                temp = 1;\n            } else if (num == 3) {\n                temp = 3;\n            } else if (num == 5) {\n                temp = 5;\n            } else {\n                temp = 99;\n            }\n        }\n        return temp;\n    }\n\n    @Benchmark\n    public int switchStatement() {\n        int temp = 0;\n\n        for (int i = 0; i < 5_000; ++i) {\n            generateRandomIntFromOneToTen();\n\n            switch (num) {\n                case 1:\n                    temp = 1;\n                    break;\n                case 3:\n                    temp = 3;\n                    break;\n                case 5:\n                    temp = 5;\n                    break;\n                default:\n                    temp = 99;\n                    break;\n            }\n        }\n        return temp;\n    }\n}\n```\n\nTABLESWITCH (case: 1, 3, 5)\n\n![스크린샷 2023-12-23 오후 9.10.43.png](https://i.imgur.com/jHuwHih.png)\n\n실행 결과 if-else문은 0.19ms, `TABLESWITCH`를 사용한 switch문은 0.18ms 소요되는걸 확인할 수 있었다.\n\n## if-else와 switch문 (LOOKUPSWITCH)의 성능차이\n\ncase의 범위를 넓혀서 `LOOKUPSWITCH`를 활용한 switch문과의 성능비교를 해보았다.\n\nLOOKUPSWITCH (case: 1, 10, 100)\n\n![스크린샷 2023-12-23 오후 9.10.43.png](https://i.imgur.com/tP9F8yG.png)\n\n실행 결과 if-else문은 0.19ms, `LOOKUPSWITCH`를 사용한 switch문은 0.21ms 소요되는걸 확인할 수 있었다.\n\n## 마무리\n\n지금까지 if-else 문과 switch 문의 성능을 비교해 보았다.\n\n이러한 성능 차이는 대부분의 경우에 있어서 실제 애플리케이션의 전체 성능에 큰 영향을 미치지는 않는다.\n하지만 비판적 사고를 갖고 당연한 것에 의문을 갖는 과정 자체가 의미 있었다고 생각한다.\n개인적으로 가독성 측면에서 switch 문을 사용하는 게 좀 더 직관적이라 생각하며 다양한 요소를 고려하여 if-else 또는 switch를 선택하는 것이 어떨까 싶다.\n\n---\n\n**참고 자료** 📚\n\n- https://stackoverflow.com/questions/10287700/difference-between-jvms-lookupswitch-and-tableswitch\n- [The Evolution Of Switch Statement From Java 7 to Java 17](https://medium.com/@javatechie/the-evolution-of-switch-statement-from-java-7-to-java-17-4b5eee8d29b7)\n","lang":"ko","allPostsInOtherLang":[]},"__N_SSG":true}