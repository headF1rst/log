{"pageProps":{"postData":{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},"detail":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming paradigm that complements Object-Oriented Programming (OOP) by addressing its limitations in enterprise application development. It allows developers to separate and modularize cross-cutting concerns like transactions, caching, and logging, enabling them to focus on business logic.\n\nSpring supports AOP using the Proxy Pattern. A proxy object intercepts method calls to the real object, applying common functionalities before and after the business logic executes.\n\nSimilarly, for transaction management, when a method annotated with `@Transactional` is called, a proxy object handles the transaction's start and end (commit/rollback) before and after the method execution. So, how is this proxy object created?\n\n---\n\n## Two Proxy Creation Methods in Spring AOP\n\nSpring offers two ways to create proxy objects: **JDK Dynamic Proxy** and **CGLIB Proxy**.\n\n**1. JDK Dynamic Proxy**\n\nThis method uses JDK's `java.lang.reflect.Proxy` class to dynamically create proxy objects at runtime that implement interfaces. The target object must implement at least one interface, and the proxy object is created based on the abstract methods of that interface.\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kp5rfzww1urar2lbcfyv.png)\n\nInterface-based proxy objects intercept method calls via an `InvocationHandler` to process additional functionalities.\nFor example, if logging is added in addition to transaction handling, another necessary proxy object is created, and methods are called in the following order:\n\n> ProxyLogging -> ProxyTransaction -> Target\n\n**2. CGLIB Proxy (Default Method)**\n\nCGLIB (Code Generation Library) is a library that can dynamically generate classes at runtime by manipulating bytecode. Unlike JDK Dynamic Proxy, it creates proxy objects by subclassing the target object. This means a proxy can be created even if the target object doesn't implement an interface. The proxy object overrides the target object's methods to intercept calls and process additional functionalities before and after method execution.\n\nSince Spring Boot 2.x, **CGLIB proxy is the default method** for creating AOP proxies, including for `@Transactional` behaviour, regardless of whether the target object implements an interface.\n\nWhile this proxy-based AOP mechanism is very powerful, it also creates certain scenarios that require caution. One common point of confusion for developers is method calls within the same class, i.e., self-invocation scenarios. With this understanding of how @Transactional operates through proxies, let's now delve into why transactions might not be applied in such self-invocation cases and the reasons behind it.\n\n---\n\n## Internal Method Calls and AOP Proxies\n\nNow that we understand the principle behind `@Transactional`, let's examine why transactions are not applied when an internal method (a method within the same class) is called, and the reasons for this behavior.\n\n```java\n@Service\n@RequiredArgsConstructor\npublic class TransportService {\n\n    private final TransportRepository transportRepository;\n\n    public void sendTransportEvents(List<Long> transportIds) {\n        transportRepository.changeStatuses(transportIds);\n        // Sending...\n    }\n}\n\n@Repository\npublic interface TransportRepository {\n    void save(Transport transport);\n\n    default void changeStatuses(List<Long> transportIds) {\n        for (Long transportId : transportIds) {\n            changeStatus(transportId); // Internal call within the proxy if TransportRepositoryImpl is proxied\n        }\n    }\n\n    void changeStatus(Long transportId);\n\n    Optional<Transport> findById(Long id);\n}\n\n@Repository\n@RequiredArgsConstructor\npublic class TransportRepositoryImpl implements TransportRepository {\n\n    private final TransportJpaRepository transportJpaRepository;\n\n    @Override\n    public void save(Transport transport) {\n        transportJpaRepository.save(transport);\n    }\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    @Override\n    public void changeStatus(Long transportId) {\n        Transport transport = transportJpaRepository.findById(transportId).orElseThrow();\n        transport.updateStatus(TransportStatus.SENT);\n    }\n\n    @Override\n    public Optional<Transport> findById(Long id) {\n        return transportJpaRepository.findById(id);\n    }\n}\n\n@SpringBootTest\nclass TransportServiceTest {\n\n    @Autowired\n    private TransportService sut;\n    @Autowired\n    private TransportRepository transportRepository; // This will be a proxy\n\n    @Test\n    void whenTransportEventsAreSent_statusChangesToSENT() {\n        // given\n        var transportA = new Transport(1L, TransportStatus.PENDING);\n        var transportB = new Transport(2L, TransportStatus.PENDING);\n        List.of(transportA, transportB).forEach(transportRepository::save);\n\n        // when\n        sut.sendTransportEvents(List.of(1L, 2L));\n\n        // then\n        var result1 = transportRepository.findById(1L).get();\n        var result2 = transportRepository.findById(2L).get();\n\n        assertThat(result1.getStatus()).isEqualTo(TransportStatus.SENT);\n        assertThat(result2.getStatus()).isEqualTo(TransportStatus.SENT);\n    }\n}\n```\n\nIn `TransportRepositoryImpl.changeStatus(transportId)`, we attempt to change the `transport's` status from PENDING to `SENT` using JPA's dirty checking. If dirty checking worked as intended, the test should pass. However, the test fails, and the status remains `PENDING`.\n\n### Why Does This Happen?\n\n```java\n@Repository\n@RequiredArgsConstructor\n@Slf4j\npublic class TransportRepositoryImpl implements TransportRepository {\n\n    private final TransportJpaRepository transportJpaRepository;\n    private final EntityManager em;\n    // ...\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    @Override\n    public void changeStatus(Long transportId) {\n        Transport transport = transportJpaRepository.findById(transportId).orElseThrow();\n        transport.updateStatus(TransportStatus.SENT);\n\n        if (em.contains(transport)) {\n            log.info(\"Entity is managed\");\n        } else {\n            log.info(\"Entity is detached\"); // This will be logged\n        }\n        log.info(\"Transaction active: {}\", TransactionSynchronizationManager.isActualTransactionActive()); // false\n    }\n}\n```\n\nFor dirty checking to work correctly, the entity must be managed by the persistence context. \n\nHowever, the logs would show that the `Transport` entity is not managed by the persistence context (Entity is detached) and that no transaction is active (Transaction active: false). This is because the transaction was not applied to this method call.\n\n![persistence](https://i.imgur.com/BANQI7X.png)\n\nThe lifecycle of the persistence context is tied to the transaction. If a transaction is not active, a persistence context is not created (or an existing one isn't joined), and thus, the entity is not managed within it. Consequently, in the `changeStatus()` method where no transaction is applied during this specific invocation path, a persistence context isn't effectively used for dirty checking.\n\nSpring creates a proxy object for `TransportRepositoryImpl` (likely using CGLIB by default). This proxy object overrides the `changeStatus()` method (which is annotated with @Transactional) to inject transaction-related logic before and after the actual method call.\n\nThe problem arises because the `TransportRepository's` default method `changeStatuses()` calls `changeStatus()` through the this reference of the proxy. However, when `changeStatuses()` (which itself is not @Transactional on the interface proxy) iterates and calls `changeStatus(transportId)`, this call is an internal invocation within the target `TransportRepositoryImpl` object if the proxy delegates to it without re-intercepting.\n\nMore precisely:\nWhen `transportRepository.changeStatuses()` is called on the proxy:\n\n1. The proxy might invoke the default method `changeStatuses()` on itself.\n2. Inside `changeStatuses()`, the call `changeStatus(transportId)` is effectively `this.changeStatus(transportId)`. If `this` refers to the raw `TransportRepositoryImpl` instance or if the proxy doesn't re-intercept calls from within itself to itself, the proxy's transactional advice for `changeStatus()` is bypassed.\n\nSpring proxies can only apply transactional (and other AOP) advice to calls that go through the proxy from an external caller. Methods called from within the same class instance (self-invocation) typically bypass the proxy mechanism, so transactions are not applied to the inner call.\n\n---\n\n## Why Do Internal Calls Bypass the Proxy?\n\nIn Spring AOP, proxies operate when called by an external client (another bean or component). When an external client calls a method on a bean that is proxied, it's actually calling a method on the proxy object. The proxy then intercepts this call, applies any configured AOP advice (like starting a transaction), and then delegates to the actual method on the target object.\n\nHowever, when a method is called from within the same class instance (e.g., `this.someOtherMethod()`), it's not an external call being made through the proxy. Instead, the method is invoked directly on the current instance's `this` reference, which refers to the raw target object, not the proxy. Therefore, the proxy's AOP advice (including transactional behavior) is bypassed.\n\nTo resolve this:\n\n1. It's recommended to apply @Transactional to methods that are called externally (e.g., directly from the `TransportService` to `transportRepository.changeStatus(id)` for each ID).\n\n2. Alternatively, you can separate the internal method that needs its own transaction into a different Spring bean so it can be called externally (i.e., injected and then called, ensuring the call goes through its proxy).\n\nIn the given example, the most straightforward fix to ensure `changeStatus` is transactional would be to call it directly from `TransportService` in a loop, or refactor `TransportRepository` so changeStatuses itself is @Transactional (if that's the desired transactional boundary) and handles the logic appropriately, or to make `changeStatuses` a method on `TransportRepositoryImpl` directly and have `TransportService` call it. The current default method on the interface makes the proxy interaction complex.\n\n---\n\n## Conclusion\n\nTo summarize, Spring's @Transactional annotation relies on AOP proxies (typically CGLIB in modern Spring Boot) to manage transactions by intercepting external method calls. A critical takeaway is that @Transactional may not apply to self-invocations because these internal calls bypass the proxy mechanism.\n\nIt's important to understand that this self-invocation challenge and the underlying proxy behavior are not exclusive to @Transactional. This is a fundamental aspect of how Spring AOP functions. Consequently, other AOP-driven features, such as declarative caching (@Cacheable), method security (@Secured, @PreAuthorize), or any custom aspects you implement, can be similarly affected by internal calls bypassing the proxy.\n\nTherefore, a solid understanding of AOP's core working principles—especially how proxies intercept external calls and why self-invocations are not subject to this interception—is paramount. This knowledge is key not just for mastering @Transactional, but for effectively utilizing the full spectrum of Spring's powerful AOP capabilities, ultimately leading to more robust and predictable applications.\n","lang":"en","allPostsInOtherLang":[{"id":"post33","lang":"ko","title":"Netty 내부 동작 원리로 파헤친 WebClient 초기 지연 이슈","date":"2025-12-26","section":"tech","tags":"Netty","thumbnail":"https://miro.medium.com/1*KNou9wcBzw1P9IrgfxrJyQ.png","preview":"\n물류 인프라를 보유하고 있는 회사들은 3PL이라는 서비스를 제공합니다. 3PL이란 물류 인프라를 갖춘 회사가 그렇지 못한 판매처로부터 배송 업무를 위탁받아 제공하는 서비스를 말합니다.\n\n판매처는 배송이 필요한 주문 목록을 3PL 시스템에 등록하게 되"},{"id":"post34","lang":"ko","title":"AI 브라우저를 활용한 PR 메세지 자동화","date":"2025-12-14","section":"tech","tags":"AI","thumbnail":"https://i.imgur.com/iJY5NAV.png","preview":"\nClaude Code, Codex 같은 코딩 에이전트의 등장으로 개발 속도는 빨라졌지만, 그만큼 PR 리뷰에 드는 시간은 이전보다 91% 증가했다고 합니다.\n저 역시 예전보다 더 많은 시간을 코드 리뷰에 할애하고 있는데요. 리뷰어로서의 피로를 체감하"},{"id":"post35","lang":"ko","title":"AI 브라우저를 활용한 PR 메세지 자동화","date":"2025-12-14","section":"domain","tags":"물류","thumbnail":"https://i.imgur.com/iJY5NAV.png","preview":""},{"id":"post32","lang":"ko","title":"Swagger의 사실과 오해: API-First Development","date":"2025-12-01","section":"tech","tags":"API","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fgw6ikg1xqngndmdycax5.png","preview":"\n개발에서 가장 중요하게 생각하는것 중 하나는 '인터페이스'입니다.\n인터페이스를 잘 정의하는 것은 시스템의 일관성과 확장성을 보장하고 변화에 유연하게 대응할 수 있는 기반이 되어줍니다.\n\n새로운 API를 개발할때 가장 먼저 마주하게 되는 인터페이스는 "},{"id":"post31","lang":"ko","title":"Resilience4j Bulkhead 패턴: 대용량 데이터 처리 안정성 높이기","date":"2025-10-24","section":"tech","tags":"Java","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fg3q8du889pux1selrwp9.png","preview":"\n물류 시스템을 개발하다 보면, 대량의 데이터를 엑셀 파일로 내보내야 하는 요구사항을 자주 마주합니다. 사용자가 지정한 기간의 데이터를 엑셀로 제공하려면, 먼저 데이터를 조회한 뒤 Apache POI로 엑셀 형식으로 변환하는 과정이 필요합니다.\n\n다만"},{"id":"post10","lang":"ko","title":"10억 달러짜리 실수 해결하기: JSpecify와 NullAway를 사용한 최신 Java Null 안전성","date":"2025-09-24","section":"tech","tags":"JSpecify","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"JSpecify 어노테이션과 NullAway 정적 분석을 사용하여 현대 Java 애플리케이션에서 NullPointerException을 제거하는 방법 학습","searchKeywords":"JSpecify, NullAway, Java null 안전성, NullPointerException 방지, 정적 분석","translationSlug":"post9","preview":"\n자바 프로그래밍을 처음 시작한 개발자부터 20년 경력의 시니어 개발자까지, 경력을 불문하고 개발자들이 가장 자주 마주치는 에러는 **NullPointerException**일 것입니다.\n\n![Top Crash Reasons](https://dev-t"},{"id":"post22","lang":"ko","title":"Anthropic 엔지니어들의 프롬프트 엔지니어링 팁","date":"2025-06-24","section":"tech","tags":"AI","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Anthropic 엔지니어들이 공유한 가치 있는 프롬프트 엔지니어링 팁과 통찰","searchKeywords":"프롬프트 엔지니어링, AI 팁, Anthropic, LLM 베스트 프랙티스","translationSlug":"post7","preview":"\n[AI prompt engineering: A deep dive](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s)에서 Anthropic 엔지니어들이 그들의 프롬프트 작성 팁과 경험을 공유했는데, 여기서 "},{"id":"post23","lang":"ko","title":"조인 테이블이 왜 생기지? @JoinColumn으로 해결하는 연관관계 매핑의 비밀","section":"tech","thumbnail":"https://velog.velcdn.com/images/wooyong99/post/6fdebd14-5fe8-4959-b085-74edb6bc4d46/image.png","tags":"JPA","date":"2024-10-10 10:00","searchKeywords":"jpa, JoinColumn, 외래 키, 외래 키 제약 조건","description":"JoinColumn","preview":"\n`@JoinColumn`은 외래키를 매핑할 때 사용한다. 즉, 한 엔티티에서 다른 엔티티를 참조(조인)하는데 사용되는 필드를 지정하는 역할을 한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter\n@No"},{"id":"post29","lang":"ko","title":"내부 메서드 호출시 트랜잭션이 적용되지 않는 이슈","section":"tech","thumbnail":"https://velog.velcdn.com/images/uiurihappy/post/0c13062e-e5cb-45f0-9727-a9ef018b1ffc/image.png","tags":"transactional","date":"2024-10-01 10:00","searchKeywords":"transactional, spring, aop","description":"Transactional 내부 메서드 호출시 트랜잭션이 적용되지 않는 이슈","preview":"\n# @Transactional 동작 원리\n\n## AOP와 프록시 패턴을 통한 트랜잭션 관리\n\nAOP는 엔터프라이즈 애플리케이션 개발에서 객체지향 프로그래밍(OOP)의 한계를 보완해주는 보조적인 프로그래밍 기법이다. 이를 통해 트랜잭션, 캐싱, 로깅 "},{"id":"post30","lang":"ko","title":"Gson 라이브러리 InaccessibleObjectException","thumbnail":"https://media.techmaster.vn/api/static/bq0a8rs51co78aldi4p0/lsRpW5hr","section":"tech","tags":"gson, Java","date":"2024-07-02 10:00","searchKeywords":"gson, java","description":"gson","preview":"\nSpring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보"},{"id":"post20","lang":"ko","title":"Fixture Monkey With Kotlin","section":"tech","thumbnail":"https://i.imgur.com/J5SIYtU.png","tags":"test","date":"2024-03-03 10:00","searchKeywords":"fixture monkey, test, fixture","description":"fixtureMonkey","preview":"\n테스트를 작성하다 보면 프로덕션 코드보다 테스트 픽스처를 만드는 데 더 많은 시간이 드는 경우가 있습니다.\n테스트 작성이 번거롭고 시간이 많이 걸릴수록 테스트 코드를 생략하게 되고, 결국 결함에 취약한 시스템을 구현할 위험이 커집니다.\n\n주문 로직을"},{"id":"post19","lang":"ko","title":"객체지향과 탈 국지화","section":"tech","thumbnail":"https://i.imgur.com/e584gko.png","tags":"객체지향","date":"2024-02-04 10:00","searchKeywords":"OOP","description":"객체지향과 탈 국지화","preview":"\n최근 두 권의 책을 병행해서 읽는 중인데 서로 조금 상반되는 내용을 읽게 되어 내 생각을 정리해 보는 시간을 가져보았다.\n\n한 권은 펠리너 헤르만스가 쓴 '[프로그래머의 뇌](https://m.yes24.com/Goods/Detail/10591101"},{"id":"post18","lang":"ko","title":"JPA 트랜잭션과 영속성 컨텍스트","section":"tech","thumbnail":"https://images.velog.io/images/dnjscksdn98/post/14072bd8-850b-4d2b-8476-cb5385bbcd36/jpa.png","tags":"JPA","date":"2024-01-07 10:00","searchKeywords":"jpa, entitymanager, 영속성 컨텍스트, 트랜잭션","description":"JPA 트랜잭션과 영속성 컨텍스트","preview":"\n최근 구현한 테스트 코드에서 `@Transactional` 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.\n\n타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로"},{"id":"post17","lang":"ko","title":"GitHub Actions를 통해 CI/CD 구축하기 (feat. Docker, Jib)","thumbnail":"https://miro.medium.com/max/1400/1*DmFbJvnRIiQIyi5xBuIXlQ.png","section":"tech","tags":"tech, 프로젝트, CI/CD, Docker","date":"2022-12-06 10:00","preview":"\n저희 `Text Me` 서비스의 베타 버전이 배포되고 난 뒤에, 사용자들로 부터 수많은 피드백을 받을 수 있었습니다. \n사용자 피드백을 빠르게 반영하다 보니 프로젝트의 빌드 및 배포 주기가 짧아졌고 이러한 과정이 서서히 번거롭게 느껴지기 시작했습니다"},{"id":"post16","lang":"ko","title":"ubuntu 18.04에 Docker 설치하기","section":"tech","thumbnail":"https://www.docker.com/wp-content/uploads/2021/09/Docker-build.png","tags":"infra","date":"2022-12-03 10:00","preview":"\n프로젝트를 진행하면서 도커 허브에 올라가있는 이미지를 가져와서 배포 환경에서 실행해야 하는 요구사항이 발생하였습니다. \n\n이를 위해서 ubuntu환경에 docker를 설치했던 과정을 공유해보겠습니다.\n\n## Docker가 지원하는 OS\n\n다음은 do"},{"id":"post15","lang":"ko","title":"[오브젝트] 13장 - 서브클래싱과 서브타이핑","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-11-29 10:00","preview":"\n상속이 사용되는 두 가지 용도\n\n- 타입 계층을 구현하는 것\n    - 부모 클래스\n        - 일반적인 개념을 구현\n        - 부모 클래스는 자식 클래스의 일반화\n    - 자식 클래스\n        - 특수한 개념을 구현\n      "},{"id":"post14","lang":"ko","title":"[오브젝트] 9장 - 유연한 설계","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-11-02 10:00","preview":"\n## 1. 개방-폐쇄 원칙 (Open-Closed Principle)\n\n- 개체는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야한다.\n    - 확장에 열려있다.\n        - 새로운 동작을 추가해서 어플리케이션의 기능을 확장할 수 "},{"id":"post13","lang":"ko","title":"어노테이션 기반 MVC로 리팩터링하기 - MVC 2편","thumbnail":"https://i.imgur.com/b9vvtK7.png","section":"tech","tags":"Spring, MVC","date":"2022-10-17 10:00","preview":"\n이번 포스트에서는 [이전 포스트](https://headf1rst.github.io/TIL/mvc1)에서 구현한 MVC 프레임워크를 \n어노테이션 기반의 MVC로 점진적으로 리팩토링해 나가는 과정에 대해서 다뤄보도록 하겠다.\n\n## 1. 불편함을 감지"},{"id":"post12","lang":"ko","title":"MVC 프레임워크 만들기 - MVC 1편","thumbnail":"https://i.imgur.com/b9vvtK7.png","section":"tech","tags":"Spring, MVC","date":"2022-10-08 10:00","preview":"\n7월에 [넥스트 스텝](https://edu.nextstep.camp/)에서 진행하는 [만들면서 배우는 스프링 3기](https://edu.nextstep.camp/s/I7LCaCf3)에 참여하였습니다.\n\n이 포스트는 해당 과정에서 스스로 고민하며 "},{"id":"post11","lang":"ko","title":"[오브젝트] 7장 - 객체 분해","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-10-02 10:00","preview":"\n모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능\n\n## 추상화 메커니즘\n시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.\n\n- 1. 프로시저 추상화\n    - 소프트웨어가 무엇을 **해야**하는지 "},{"id":"post9","lang":"ko","title":"다중 요청 처리를 위한 ThreadPool 적용하기","thumbnail":"https://i.imgur.com/mHibXLP.jpg","section":"tech","tags":"Spring, ThreadPool","date":"2022-09-20 10:00","preview":"\n프레임워크는 개발자가 쉽고 편하게 개발을 할 수 있도록 많은 기술을 추상화해서 제공한다.\n\n스프링 또한 많은 부분이 추상화 되었으며 개발자 스스로가 의문을 갖지 않는다면, 모른채 넘어갈 기술들이 여럿 존재한다.\n\n오늘은 그러한 기술들 중, 개발자들을"},{"id":"post8","lang":"ko","title":"[오브젝트] 5장 - 책임 할당하기","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-09-19 10:00","preview":"\n## 책임 중심 설계\n\n- 어떤 객체에게 어던 책임을 할당할지 결정해야한다\n- 문제 해결을 위한 다양한 책임 할당 방법이 존재하며 일종의 트레이드오프 활동이다.\n- 상황과 문맥에 따라 최적의 책임 할당 방법을 선택해야한다.\n\n- 책임 중심 설계를 위"},{"id":"post7","lang":"ko","title":"[오브젝트] 4장 - 설계 품질과 트레이드오프","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","section":"tech","tags":"객체지향","date":"2022-09-12 10:00","preview":"\n좋은 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 캡슐화를 통해 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 것\n\n- 구현\n    - 변경될 가능성이 높은 부분\n- 인터페이스\n    - 상대적으로 안정적인 부분\n\n- 변경의 정도에 "},{"id":"post6","lang":"ko","title":"[오브젝트] 3장 - 역할, 책임, 협력","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-09-05 10:00","preview":"\n- 객체지향의 본질 : 협력하는 객체들의 공동체를 창조하는 것\n    - 기능 구현을 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할, 책임이 필요한지 파악\n\n- 객체들은 메시지를 주고 받으며 협력한다\n\n- `협력`\n    - 어플리케이션 기능 구"},{"id":"post5","lang":"ko","title":"[오브젝트] 2장 - 객체지향 프로그래밍","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-08-29 10:00","preview":"\n클래스를 먼저 결정하고, 어떤 `속성`과 `메서드`가 필요한지 고민하는것리 아니라 `객체`에 초점을 맞춰야한다\n\n1. 어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라\n   클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것\n\n2."},{"id":"post4","lang":"ko","title":"[오브젝트] 1장 - 객체, 설계","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-08-22 10:00","preview":"\n`패러다임` - 한 시대의 사회 전체가 공유하는 이론 혹은 방법.\n절차형 → 객체지향으로 패러다임 전환을 맞았다.\n\n프로그래밍 패러다임은 과거의 패러다임을 폐기시키는 혁명적 패러다임이 아니라 과거의 패러다임을 개선하는 `발전적 패러다임`이다.\n\n객체"},{"id":"post2","lang":"ko","title":"Static 변수 저장위치와 JVM 구조의 변화","section":"tech","thumbnail":"https://i.imgur.com/5AJJwhh.png","tags":"Java, JVM","date":"2022-07-11 10:00","searchKeywords":"자바, jvm, 정적 변수","description":"Static 변수 저장위치와 JVM 구조의 변화","preview":"\nStatic 키워드를 사용하여 정적 변수와 정적 메서드를 만들수 있는데, 이들을 정적 멤버 (혹은 클래스 멤버) 라고 합니다.\n\n```java\nclass Lesson {\n\t\tstatic int score = 0;\n\t\tstatic String grad"},{"id":"post1","lang":"ko","title":"CORS, 알고보니 우리편?","section":"tech","thumbnail":"https://user-images.githubusercontent.com/85024598/236966566-6127653c-7540-485e-859f-01240e7e7154.png","tags":"프로젝트","date":"2022-05-26 10:00","preview":"\nServer Side Template 방식이 아닌 프론트와 백으로 나눠서 API 통신을 하는\n프로젝트의 경우, 열에 아홉은 만나게 되는게 바로 `CORS` 입니다.\n\n아니나 다를까 현재 진행중인 프로젝트에서도 CORS 관련 이슈가 올라왔습니다.\n\n!"},{"id":"post3","lang":"ko","title":"내가 블로그를 새로 시작하는 이유","thumbnail":"https://i.imgur.com/HbkinoQ.jpg","section":"tech","tags":"회고","date":"2022-04-02 10:00","preview":"\n## 앵무새식 블로그 글\n\n처음 블로그를 시작하는 경우에 `TIL (Today I Learned)` 을 목적으로 하루에 하나의 포스팅을 하는 경우를 주위에서 많이 봤고 나 또한 그랬다.\n\n그 당시에는 하나의 포스팅을 마치고 나면 마치 해당 주제에 대"}]},"__N_SSG":true}