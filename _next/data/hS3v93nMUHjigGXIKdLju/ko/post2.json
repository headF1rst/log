{"pageProps":{"postData":{"id":"post2","lang":"ko","title":"Static 변수 저장위치와 JVM 구조의 변화","section":"tech","thumbnail":"https://i.imgur.com/5AJJwhh.png","tags":"Java, JVM","date":"2022-07-11 10:00","searchKeywords":"자바, jvm, 정적 변수","description":"Static 변수 저장위치와 JVM 구조의 변화","preview":"\nStatic 키워드를 사용하여 정적 변수와 정적 메서드를 만들수 있는데, 이들을 정적 멤버 (혹은 클래스 멤버) 라고 합니다.\n\n```java\nclass Lesson {\n\t\tstatic int score = 0;\n\t\tstatic String grad"},"detail":"\nStatic 키워드를 사용하여 정적 변수와 정적 메서드를 만들수 있는데, 이들을 정적 멤버 (혹은 클래스 멤버) 라고 합니다.\n\n```java\nclass Lesson {\n\t\tstatic int score = 0;\n\t\tstatic String grade = 'F';\n\n\t\tstatic void getScore() {\n\t\t\t ...\n\t\t}\n}\n```\n\nLesson 클래스(Class)는 Method Area에 생성되고, new 연산을 통해 생성한 Lesson 클래스의 객체(Object)는 Heap **영역**에 생성됩니다.\n\n![Untitled](https://i.imgur.com/Stip2zD.png)\n\n그렇다면 정적 멤버들은 메모리상의 어느 위치에 저장이 될까요?\n\n정적 멤버(클래스 멤버)는 말 그대로 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버입니다. \n\n그렇기 때문에, 정적 멤버는 Class와 함께 클래스 로더에 의해서 **Method Area**에 저장되지 않을까요?\n\n저의 이 생각은 Java 7까지는 맞지만 Java 8부터는 반만 맞는 대답이 되고 말았습니다.\n\n왜 Java 8부터는 반만 맞는 대답인걸까요?\n\n그 이유는 Java 7과 8의 JVM 구조에 변화가 있었기 때문입니다.\n\n## Java 7의 HotSpot JVM 힙 그리고 static 변수\n\nJava 7 버전까지만 해도 정적 멤버들은 Method Area를 포함하고 있는  `PermGen` 영역에 저장되었었습니다.\n\n![스크린샷 2022-07-16 오전 11.14.55.png](https://i.imgur.com/TK8mAwL.png)\n\nPermGen은 정적 멤버 외에도, **클래스 메타 데이터, interned String이 저장되었습니다.**\n\n- 클래스 메타데이터 : 클래스의 이름, 생성정보, 필드정보, 메서드 정보 등\n\n하지만 문제는 PermGen 영역이 매우 제한적인 크기를 갖고 있다는 것이었습니다.\n\nPermGen 영역의 default 크기는, 32-bit JVM에선 64M, 64-bit에선 84M에 불과합니다.\n\n때문에, 클래스 로딩이 많아지게 되면 사용 가능한 메모리가 부족해서 다음과 같은 에러가 발생하고는 했습니다.\n\n```java\njava.lang.OutOfMemoryError: PermGen space\n```\n\n뿐만 아니라, JVM은 PermGen 영역의 사이즈를 유지시키기 위해서 주기적으로 Garbage Collection연산을 수행하게 되는데 이는 성능 이슈를 야기했습니다.\n\n물론 `-XX:PermSize` , `-XX:MaxPermSize` 와 같은 명령어를 통해서 사용자가 직접 PermGen영역을 설정해 주는것이 가능했습니다.\n\n하지만 자동으로 영역의 사이즈가 늘어나지 않았고, 매모리 가용 용량을 미리 예측해서 설정하는것은 쉽지 않은 일이었습니다.\n\n## Java 8의 Hotspot JVM 그리고 static 변수\n\n이러한 문제를 해결하기 위해서 Java 8에선 PermGen 영역이 없어지고 `MetaSpace` 영역이 새로 생겼습니다.\n\nMetaspace 영역은 힙이 아닌 Native 메모리 영역으로 취급됩니다.\n\n![스크린샷 2022-07-16 오전 11.14.20.png](https://i.imgur.com/4VucRG4.png)\n\n[https://openjdk.org/jeps/122](https://openjdk.org/jeps/122)\n\n힙 영역은 JVM에 의해 관리되는 영역이지만 Native 메모리 영역은 OS 레벨에서 관리하는 영역입니다.\n\n즉, Metaspace가 Native 메모리를 이용함으로써 개발자는 영역 확보의 상한을 크게 의식할 필요가 없어지게 되었습니다. (metaspace의 사이즈는 auto increase 됩니다)\n\n`metaspace` 에서는 **클래스 메타 데이터**만을 저장하고 정적 멤버와 interned string은 힙에서 관리되게 되었습니다.\n\nMetaspace는 클래스 메타 데이터를 native메모리에 저장하고 부족할 경우 자동으로 늘려줍니다.\n\n덕분에 더이상 PermSize 설정을 고려할 필요가 없어졌고 MetaspaceSize, MaxMetaspaceSize가 새롭게 사용되게 되었습니다. \n\n만약 별도의 MetaspaceSize 설정을 하지 않으면 Native memory 자원을 최대한 사용하게 됩니다.\n\n(Default jvm MaxMetaspaceSize = None)\n\n## 결론\n\n요약하자면, Java 7에서는 정적 멤버 변수가 PermGen(Method Area)에 저장되었습니다.\n\n하지만 메모리 관리상의 문제로 인해 PermGen 영역이 사라지고 Metaspace 영역이 등장하면서, 정적 멤버 변수는 힙에 저장이 되도록 변경 되었습니다.\n\n**참고 자료**\n\n[JEP 122: Remove the Permanent Generation](https://openjdk.org/jeps/122)\n\n[Where are static methods and static variables stored in Java?](https://stackoverflow.com/questions/8387989/where-are-static-methods-and-static-variables-stored-in-java)\n\n[Java PermGen의 역사](https://blog.voidmainvoid.net/315)\n\n[Hotspot JVM의 힙 구조](https://77loopin.github.io/java/Java-1/)\n\n[https://www.geeksforgeeks.org/metaspace-in-java-8-with-examples/#:~:text=Method Area is a part,which leads to an OutOfMemoryError](https://www.geeksforgeeks.org/metaspace-in-java-8-with-examples/#:~:text=Method%20Area%20is%20a%20part,which%20leads%20to%20an%20OutOfMemoryError).\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}