{"pageProps":{"postData":{"id":"post23","lang":"ko","title":"조인 테이블이 왜 생기지? @JoinColumn으로 해결하는 연관관계 매핑의 비밀","section":"tech","thumbnail":"https://velog.velcdn.com/images/wooyong99/post/6fdebd14-5fe8-4959-b085-74edb6bc4d46/image.png","tags":"JPA","date":"2024-10-10 10:00","searchKeywords":"jpa, JoinColumn, 외래 키, 외래 키 제약 조건","description":"JoinColumn","preview":"\n`@JoinColumn`은 외래키를 매핑할 때 사용한다. 즉, 한 엔티티에서 다른 엔티티를 참조(조인)하는데 사용되는 필드를 지정하는 역할을 한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter\n@No"},"detail":"\n`@JoinColumn`은 외래키를 매핑할 때 사용한다. 즉, 한 엔티티에서 다른 엔티티를 참조(조인)하는데 사용되는 필드를 지정하는 역할을 한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter\n@NoArgsConstructor  \npublic class Order {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    @ManyToOne  \n    @JoinColumn(name = \"customer_id\") // 외래 키로 지정\n    private Customer customer;\n  \n    public Order(Customer customer) {  \n        this.customer = customer;  \n    }  \n}\n```\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    private String name;  \n  \n    public Customer(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n`@JoinColumn(name = \"customer_id\")`는 Order 테이블에서 `customer_id`라는 컬럼을 통해 `Customer` 엔티티를 참조하는 외래 키를 정의한다.\n\n`@ManyToOne`의 기본 FetchType이 EAGER이기 때문에, Order 조회시 연관된 Customer 엔티티도 함께 `@JoinColumn`에 명시된 필드를 통해 참조(조인)하여 가져오는걸 볼 수 있다.\n\n```java\n@SpringBootTest  \nclass OrderTest {  \n  \n    @Autowired  \n    private OrderRepository orderRepository;  \n    @Autowired  \n    private CustomerRepository customerRepository;  \n  \n    @Test  \n    void joinColumnTest() {  \n        var customer = customerRepository.save( new Customer(\"John Doe\"));  \n        var order = orderRepository.save(new Order(customer));  \n  \n        Order result = orderRepository.findById(order.getId()).get();  \n    }\n}\n```\n\n```\nHibernate: \n    select\n        o1_0.id,\n        c1_0.id,\n        c1_0.name \n    from\n        orders o1_0 \n    left join\n        customer c1_0 \n            on c1_0.id=o1_0.customer_id \n    where\n        o1_0.id=?\n```\n\n`@JoinColumn`은 ConstraintMode 옵션 값을 통해서 외래 키 제약 조건을 걸 수 있다.\n\n- **ConstraintMode.PROVIDER_DEFAULT** (기본값): JPA Provider의 외래 키 제약 조건 생성 전략을 따른다. Hibernate는 이 옵션 값에서 외래 키 제약 조건을 설정한다.\n- **ConstraintMode.CONSTRAINT**: 해당 외래 키 컬럼에 데이터베이스 레벨에서 외래 키 제약 조건을 설정한다.\n- **ConstraintMode.NO_CONSTRAIN**: DB에 외래키 제약조건을 걸지 않는다.\n    - 외래 키 컬럼은 생성되지만 DB가 그 컬럼의 값을 검증하거나 무결성을 유지하지는 않는다.\n\n# @JoinColumn은 생략해도 될까\n\n단방향 `@ManyToOne` 에선 `@JoinColumn`을 생략 할 수 있다. `@JoinColumn`을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다. 실제로 앞의 예제 코드에서 `@JoinColumn`을 생략하고 테스트를 실행했을때 동일한 로그가 출력되는걸 확인할 수 있었다.\n\n> 기본 전략: 필드명 + _ + 참조하는 테이블의 컬럼명\n> \n> ex) customer + _ + id -> customer_id\n\n그러나 단방향 `@OneToMany` 연관관계에서 `@JoinColumn`을 생략할 경우, JPA는 조인 테이블을 생성하여 엔티티간의 관계를 관리한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter  \n@NoArgsConstructor  \npublic class Order {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n\n\t@Column(name = \"customer_id\")\n    private Long customerId;  \n  \n    public Order(Long customerId) {  \n        this.customerId = customerId;  \n    }  \n}\n```\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    @OneToMany(cascade = CascadeType.ALL)  \n    private List<Order> orders = new ArrayList<>();\n  \n    private String name;  \n  \n    public Customer(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n```java\n@SpringBootTest  \nclass OrderTest {  \n  \n    @Autowired  \n    private OrderRepository orderRepository;  \n    @Autowired  \n    private CustomerRepository customerRepository;  \n  \n    @Test  \n\t@Transactional  \n\tpublic void joinColumnTest() {  \n\t    Customer customer = new Customer(\"John Doe\");  \n\t    List<Order> orders = List.of(\n\t\t    new Order(customer.getId()), \n\t\t    new Order(customer.getId())\n\t\t);\n\t    customer.getOrders().addAll(orders);  \n  \n\t    customerRepository.save(customer);  \n\t    orderRepository.saveAll(orders);  \n\t}\n}\n```\n\n테스트 실행 후 로그를 확인해보면 `customer_orders` 조인 테이블이 생성된것을 확인할 수 있다.\n\n![log](https://i.imgur.com/v332oJ2.png)\n\n# 왜 조인 테이블이 생성될까?\n\n단방향 `@OneToMany` 관계에서는 JPA가 어느 테이블에 외래 키를 두어야 할지 명확하지 않기 때문에, 중간 조인 테이블을 생성하여 관계를 관리한다.\n\n조인 테이블이 생성되는 것을 방지하고 싶다면, `@JoinColumn`을 명시적으로 설정하여 외래 키를 직접 관리하도록 해야 한다.\n아래와 같이 `@JoinColumn(name = \"customer_id\"...)`를 설정하여 외래키를 Order 테이블에 설정할 수 있다.\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n\t//...\n\t\n    @OneToMany(cascade = CascadeType.ALL)  \n    @JoinColumn(name = \"customer_id\", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))  \n    private List<Order> orders = new ArrayList<>();  \n  \n    //...\n}\n```\n\n다시 테스트를 실행하고 로그를 확인해 보면 조인 테이블이 생성되지 않은걸 확인할 수 있다.\n\n![log](https://i.imgur.com/1RLHtIp.png)\n\n---\n\n**참고 자료**\n- [@ManyToOne을 사용할 때 @JoinColumn 생략](https://hyeon9mak.github.io/omit-join-column-when-using-many-to-one/)\n\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}