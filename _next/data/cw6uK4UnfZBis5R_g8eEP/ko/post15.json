{"pageProps":{"postData":{"id":"post15","lang":"ko","title":"[오브젝트] 13장 - 서브클래싱과 서브타이핑","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-11-29 10:00","preview":"\n상속이 사용되는 두 가지 용도\n\n- 타입 계층을 구현하는 것\n    - 부모 클래스\n        - 일반적인 개념을 구현\n        - 부모 클래스는 자식 클래스의 일반화\n    - 자식 클래스\n        - 특수한 개념을 구현\n      "},"detail":"\n상속이 사용되는 두 가지 용도\n\n- 타입 계층을 구현하는 것\n    - 부모 클래스\n        - 일반적인 개념을 구현\n        - 부모 클래스는 자식 클래스의 일반화\n    - 자식 클래스\n        - 특수한 개념을 구현\n        - 자식 클래스는 부모 클래스의 특수화\n- 코드 재사용\n    - 부모 클래스의 코드를 재사용하는 것이 가능\n    - 단, 부모, 자식 클래스가 강하게 결합되어 변경하기 어려운 코드가 탄생\n\n- 상속의 사용 이유는 `타입 계층을 구현하는 것`이어야 한다.\n    - 객체의 행동을 기반으로 타입 계층을 구성해야한다.\n\n## 1. 올바른 타입 계층을 구성하는 원칙\n\n### 개념 관점의 타입\n\n- 타입\n    - 공통의 특징을 공유하는  대상들의 분류\n    - 사물을 분류하기 위한 틀\n    - ex) `자바, 루비, 자바스크립트` - 프로그래밍 언어 타입\n- 타입의 인스턴스 (객체)\n    - 타입으로 분류되는 대상\n    - ex) `자바` - 프로그래밍 언어의 인스턴스\n\n- 타입의 구성 요소\n    - 심볼: 타입의 이름\n    - 내연: 타임의 정의. 타입에 속한 객체들이 가지는 공통적인 속성, 행동\n    - 외연: 타입에 속하는 객체들의 집합\n\n### 프로그래밍 언어 관점의 타입\n\n하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급.\n비트 자체에는 타입이라는 개념이 존재하지 않기 때문에 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 어플리케이션에 의해 결정된다.\n\n- 타입\n    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합\n    - 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙\n- 타입의 두 가지 목적\n    - 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한하여 프로그래머의 실수를 방지\n    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공\n        - a와 b에 부여된 타입이 `+` 연산자의 문맥을 정의.\n        - new 연산자는 타입에 정의된 만큼 저장 공간을 할당하고 객체를 초기화하기 위해 타입 생성자를 자동으로 호출\n\n### 객체지향 패러다임 관점의 타입\n\n- 타입\n    - 객체의 퍼블릭 인터페이스를 정의하는 것\n        - 퍼블릭 인터페이스\n            - 객체가 수신할 수 있는 메시지의 집합\n    - 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입\n        - 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류\n\n## 2. 타입 계층\n\n타입 계층은 포함 관계로 연결되어있다.\n\n퍼블릭 인터페이스 관점에서의 슈퍼타입과 서브타입\n\n- 슈퍼타입\n    - 서브타입이 정의한 퍼블릭 인터페이스를 인반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.\n- 서브타입\n    - 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.\n    - 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.\n\n## 3. 서브클래싱과 서브타이핑\n\n타입 계층을 구현할 때 지켜야 하는 제약사항\n\n### 언제 상속을 사용해야 하는가?\n\n상속의 올바른 용도는 `타입 계층`을 구현하는 것.\n아래 두 질문에 모두 '예'라고 답할 수 있을때만 상속을 사용.\n\n- 상속 관계가 is-a 관계를 모델링하는가?\n    - [자식 클래스]는 [부모 클래스]다 라고 말해도 이상하지 않는 경우\n    - 단, 어휘적 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.\n- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? ⭐️\n    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. - `자식 클래스와 부모 클래스의 행동 호환성`\n\n`팽귄과 새`는 is-a 관계로 묶을 수 있지만 새와 팽귄의 서로 다른 행동 방식 (날 수 있는지 여부)은 동일한 타입 계층으로 묶어서는 안된다고 경고한다.\n\n### 행동 호환성\n\n- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.\n- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점\n    - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.\n\n### 클라이언트의 기대에 따라 계층을 분리하라.\n\n행동 호환성을 만족시키지 않는 상속 계층을 유지하기란 쉽지 않다.\n클라이언트의 기대에 맞게 상속 계층을 분리하라.\n\n- 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.\n    - 인터페이스 분리 원칙 (ISP)\n- 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니므로 상속을 사용해서는 안된다.\n\n### 서브클래싱과 서브타이핑\n\n- 서브클래싱\n    - 코드 재사용 목적으로 상속을 사용하는 경우\n    - 자식 클래스와 부모 클래스의 행동이 호환되지 않는다.\n        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.\n- 서브타이핑\n    - 타입 계층 구성을 위해 상속을 사용하는 경우\n    - 자식 클래스와 부모 클래스의 행동이 호환된다.\n        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. (LSP)\n        - 부모 클래스는 자식 클래스의 `슈퍼타입`이 된다.\n        - 자식 클래스는 부모 클래스의 `서브타입`이 된다.\n\n## 4. 리스코프 치환 원칙\n\n상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키며 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.\n\n### 리스코프 치환 원칙을 위반하는 is-a 관계 (정사각형, 직사각형)\n\n```java\npublic class Rectangle {\n\n\tprivate int x, y, width, height;\n\n\tpublic Rectangle(int x, int y, int width, int height) {\n\t\t// 생략\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic void setHeigth(int height) {\n\t\tthis.height = height;\n\t}\n}\n```\n\n```java\npublic class Square extends Rectangle {\n\n\tpublic Square(int x, int y, int size) {\n\t\tsuper(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic void setWidth(int width) {\n\t\tsuper.setWidth(width);\n\t\tsuper.setHeight(width);\n\t}\n\n\t@Override\n\tpublic void setHeight(int height) {\n\t\tsuper.setWidth(height);\n\t\tsuper.setHeight(height);\n\t}\n}\n```\n\n```java\npublic void resize(Rectangle rectangle, int width, int height) {\n\trectangle.setWidth(width);\n\trectangle.setHeight(height);\n\tassert rectangle.getWidth() == width && rectangle.getHeight() == height;\n}\n```\n\n클라이언트가 `resize()` 메서드를 사용한다고 할때,\n\n- `Rectangle`을 사용하는 클라이언트는\n    - Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발.\n    - 하지만 `Square` 는 너비와 높이가 항상 같다.\n    - Ractangle을 Square로 대체할 경우 Rectangle에 세워진 가정을 위반할 확률이 높다.\n\n- is-a 관계의 문장 앞에 `\"클라이언트 입장에서\"`라는 말이 빠져 있다고 생각하라.\n- 클라이언트 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.\n\n### 느낀점\n\n면접 단골 예상 질문이라며 인터페이스와 추상 클래스의 차이점에 대한 질문을 본적이 있습니다. 자바8, 9로 넘어오면서 부터는 인터페이스에서도 디폴트 메서드를 정의하거나 private 메서드를 정의하는것이 가능해 졌습니다.\n\n이처럼 인터페이스가 점점 추상 클래스의 역할까지 담당해 나가고 있고 인프런 강의 영상에서도 점점 추상클래스를 사용하지 않고 있다는 말을 들은적이 있습니다. 때문에 문득 그럼에도 추상클래스가 필요한 이유가 있을까?라는 의문을 갖고 찾아보게 되었습니다.\n\n- 인터페이스에선 `final` 메서드를 정의할 수 없다.\n    - 서브클래스에서 어떠한 메서드가 재정의 (오버라이드)되는 것을 의도적으로 막기 위해서는 final 메서드가 필요하다\n- 인터페이스는 상태를 갖지 못한다.\n- 커뮤니케이션 가치\n    - 인터페이스는 구현해야하는 존재\n    - 구현될 필요가 없는 인터페이스를 의도하고 작성하였지만 누군가는 인터페이스를 보고 구현해야 할 존재로 바라볼 수 있다. 즉, 사람들의 예상과 다른 코드를 작성하여 오해를 불러 일으키는 코드를 작성하게 된다.\n- 생성자를 선언하지 못한다.\n\nhttps://www.quora.com/Do-we-need-abstract-classes-anymore-when-we-have-Java-8s-interfaces-with-default-and-static-methods\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}