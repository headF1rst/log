{"pageProps":{"postData":{"id":"post20","lang":"ko","title":"Fixture Monkey With Kotlin","section":"tech","thumbnail":"https://i.imgur.com/J5SIYtU.png","tags":"test","date":"2024-03-03 10:00","searchKeywords":"fixture monkey, test, fixture","description":"fixtureMonkey","preview":"\n테스트를 작성하다 보면 프로덕션 코드보다 테스트 픽스처를 만드는 데 더 많은 시간이 드는 경우가 있습니다.\n테스트 작성이 번거롭고 시간이 많이 걸릴수록 테스트 코드를 생략하게 되고, 결국 결함에 취약한 시스템을 구현할 위험이 커집니다.\n\n주문 로직을"},"detail":"\n테스트를 작성하다 보면 프로덕션 코드보다 테스트 픽스처를 만드는 데 더 많은 시간이 드는 경우가 있습니다.\n테스트 작성이 번거롭고 시간이 많이 걸릴수록 테스트 코드를 생략하게 되고, 결국 결함에 취약한 시스템을 구현할 위험이 커집니다.\n\n주문 로직을 테스트하기 위해 Order 픽스처를 만들어야 했는데, Order 객체 내부 필드만 24개였고 내부 객체의 필드까지 합치면 정의해야 할 필드가 수십 개에 달했습니다. 게다가 케이스마다 다른 상태를 가진 Order 픽스처를 추가로 만들어야 해서 테스트 준비에 상당한 시간이 소요되었습니다.\n\n그러던 중 `Fixture Monkey`라는 PBT(Property Based Testing) 라이브러리를 알게 되었고, 이를 활용해 테스트를 훨씬 편리하게 작성할 수 있었습니다. 오늘은 개인적으로 유용하게 사용했던 핵심 기능을 간략히 소개하고자 합니다.\n\n## FixtureMonkey의 주요 기능\n\n- 랜덤하고 복잡한 제약 조건을 가진 객체를 자동 생성합니다\n- 설정한 제약 조건을 검증할 수 있습니다\n- 테스트 케이스마다 객체를 유연하게 제어할 수 있습니다\n\n`FixtureMonkey`는 엔티티 필드에 지정된 Bean Validation 어노테이션에 따라 유효한 속성값을 가진 객체를 생성합니다.\n\n실패 테스트 작성처럼 특정 케이스에서 조건을 추가하거나 제약을 벗어난 필드를 설정해야 할 경우, `ArbitraryBuilder`를 사용해 픽스처를 제어할 수 있습니다. `ArbitraryBuilder`는 빌더 패턴을 통해 객체의 필드값을 원하는 대로 설정하여 생성할 수 있습니다.\n\n## 예제\n\n### Without FixtureMonkey Test\n\n`FixtureMonkey`의 편리함을 살펴보기에 앞서, 먼저 기존 방식으로 테스트를 작성해 보겠습니다.\n\n다음은 주문 과정에서 입력된 배송지 주소가 유효한지 검증하는 테스트입니다.\n\n```kotlin\ndata class Order(  \n    val product: List<Product>,  \n    val purchaserName: String,  \n    val receiver: Receiver,  \n    val totalPrice: Long,  \n    val coupon: List<Coupon>,  \n    val delivery: Delivery,  \n)\n```\n\n```kotlin\nclass OrderFixture {  \n    companion object {  \n        fun create(  \n            id: Long = 1L,  \n            product: List<Product> = listOf(  \n                Product(name = \"초콜릿\", price = 300L),  \n                Product(name = \"키보드\", price = 20000L),  \n            ),  \n            purchaserName: String = \"홍길동\",  \n            receiver: Receiver = Receiver(name = \"홍길동\", \"01012341234\"),  \n            totalPrice: Long = 20300L,  \n            coupon: List<Coupon> = listOf(Coupon()),  \n            delivery: Delivery = Delivery(\"경기도\", \"203동 1023호\", true),  \n        ): Order {  \n            return Order(  \n                id = id,  \n                product = product,  \n                purchaserName = purchaserName,  \n                receiver = receiver,  \n                totalPrice = totalPrice,  \n                coupon = coupon,  \n                delivery = delivery,  \n            )  \n        }  \n    }  \n}\n```\n\n```kotlin\nclass OrderServiceTestWithOutFixtureMonkey : DescribeSpec({  \n    val sut = OrderService()  \n    val log = LoggerFactory.getLogger(this.javaClass)  \n  \n    describe(\"배송 주소 유효성 검사\") {  \n        it(\"유효성 검증을 통과한다.\") {  \n            val order = OrderFixture.create()  \n  \n            shouldNotThrowAny {  \n                sut.validateDeliveryAddress(order)  \n            }  \n        }  \n        it(\"지번 주소를 입력받았을 경우, 상세 주소가 없으면 안 된다\") {  \n            val order = OrderFixture.create(delivery = Delivery(baseAddress = \"경기도\", road = false, detailAddress = null))  \n  \n            val exception = shouldThrow<IllegalArgumentException> {  \n                sut.validateDeliveryAddress(order)  \n            }  \n  \n            exception.message shouldBe \"지번 주소에는 상세 주소가 반드시 필요합니다.\"  \n        }  \n    }})\n```\n\n테스트 성공과 실패 케이스를 위한 `OrderFixture` 객체를 정의하여 사용했습니다. `Order` 객체에 정의된 필드뿐만 아니라 연관된 객체의 필드값들도 함께 정의해야 하기 때문에 상당히 번거로운 작업입니다.\n만약 연관된 엔티티가 더 많고 정의해야 할 필드 수가 훨씬 많아진다면, 테스트 픽스처를 정의하는 데 큰 비용이 소모됩니다.\n\n### FixtureMonkey Test\n\n이번에는 `FixtureMonkey`를 사용해 간단하게 픽스처를 생성하여 테스트를 작성해 보겠습니다.\n\n먼저 `build.gradle.kts`에 의존성을 추가합니다.\n\n```gradle\n// fixture monkey  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.0.14\")  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:0.6.3\")  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-jackson:0.6.3\")\n```\n\n**DefaultMonkeyCreator**\n```kotlin\nfun monkey() : FixtureMonkey {  \n    return FixtureMonkey.builder()  \n        .plugin(KotlinPlugin())  \n        .build()  \n}\n```\n\n**FixtureBuilders**\n```kotlin\nfun <T> defaultFixtureBuilder(clazz: Class<T>): ArbitraryBuilder<T> {  \n    return monkey().giveMeBuilder(clazz)  \n}\n```\n\n```kotlin\nclass OrderServiceTestWithFixtureMonkey: DescribeSpec({  \n    val sut = OrderService()  \n    val log = LoggerFactory.getLogger(this.javaClass)  \n  \n    describe(\"배송 주소 유효성 검사\") {  \n        it(\"유효성 검증을 통과한다.\") {  \n            val order = defaultFixtureBuilder(Order::class.java)  \n                .setExp(  \n                    Order::delivery,  \n                    Delivery(baseAddress = \"경기도\", detailAddress = null, road = true))  \n                .sample()  \n  \n            shouldNotThrowAny {  \n                sut.validateDeliveryAddress(order)  \n            }  \n        }  \n        it(\"지번 주소를 입력받았을 경우, 상세 주소가 없으면 안 된다\") {  \n            val order = defaultFixtureBuilder(Order::class.java)  \n                .setExp(  \n                    Order::delivery,  \n                    Delivery(baseAddress = \"경기도\", detailAddress = null, road = false))  \n                .sample()  \n  \n            val exception = shouldThrow<IllegalArgumentException> {  \n                sut.validateDeliveryAddress(order)  \n            }  \n  \n            exception.message shouldBe \"지번 주소에는 상세 주소가 반드시 필요합니다.\"  \n        }  \n    }})\n```\n\n이처럼 `FixtureMonkey`를 사용하면 랜덤한 필드값을 가진 픽스처 객체를 손쉽게 생성할 수 있습니다.\n\n`setter`를 통해서 객체를 제어할 수 있는데, 테스트하고자 하는 필드만 명확히 표현하기 때문에 테스트의 관심사를 바로 파악할 수 있다는 장점이 있습니다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}