{"pageProps":{"postData":{"id":"post19","lang":"ko","title":"객체지향과 탈 국지화","section":"tech","thumbnail":"https://i.imgur.com/e584gko.png","tags":"객체지향","date":"2024-02-04 10:00","searchKeywords":"OOP","description":"객체지향과 탈 국지화","preview":"\n최근 두 권의 책을 병행해서 읽는 중인데 서로 조금 상반되는 내용을 읽게 되어 내 생각을 정리해 보는 시간을 가져보았다.\n\n한 권은 펠리너 헤르만스가 쓴 '[프로그래머의 뇌](https://m.yes24.com/Goods/Detail/10591101"},"detail":"\n최근 두 권의 책을 병행해서 읽는 중인데 서로 조금 상반되는 내용을 읽게 되어 내 생각을 정리해 보는 시간을 가져보았다.\n\n한 권은 펠리너 헤르만스가 쓴 '[프로그래머의 뇌](https://m.yes24.com/Goods/Detail/105911017)'이고 다른 한 권은 조영호 님이 쓴 '[오브젝트](https://m.yes24.com/Goods/Detail/74219491)'이다.\n\n두 권 모두 읽게 된 계기가 있다. 프로그래머의 뇌는 기능을 추가하거나 수정할 때 코드를 읽고 영향도를 파악하는 역량이 부족하다고 느껴서 읽게 되었고\n오브젝트는 작년에 한 번 읽었지만 내용을 다 까먹기도 했고 마침 사내 스터디를 모집해서 읽게 되었다.\n\n두 책의 상반된다고 느꼈던 부분을 먼저 정리해 보았다.\n\n## 코드 분석과 인지 과정\n\n'프로그래머의 뇌'에서는 개발자가 코드를 읽을 때 세 가지 인지 과정이 일어난다고 설명하고 있다.\n\n첫 번째는 `LTM(Long Term Memory)`으로 컴퓨터의 하드디스크같이 장기 기억 저장소라고 할 수 있다.\n이는 반복 학습을 통해서 개발자가 습득한 지식으로\n이미 알고 있는 지식을 기반으로 코드를 청크내어 읽고 분석할 수 있기 때문에 코드를 파악하는데 드는 인지적 부하를 줄여준다.\n\n다음과 같은 피보나치수열의 경우, 재귀 함수의 기본 구조에 대한 이해가 LTM에 없다면 코드를 파악하고 분석하는데 더 큰 비용과 노력이 필요하게 된다.\n\n```kotlin\nfun fibonacci(n: Int): Int {\n    return if (n <= 1) n\n    else fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfun main() {\n    println(fibonacci(10))\n}\n```\n\n두 번째는 `STM(Short Term Memory)`으로 컴퓨터의 메인 메모리와 유사하게, 한 번에 한정된 정보만을 처리할 수 있다.\n새로운 코드를 읽을 때, 개발자는 변수 이름, 함수 호출, 알고리즘의 로직 등과 같은 여러 정보를 STM에 저장한다.\n하지만 STM의 용량에는 제한이 있기 때문에 많은 정보를 저장하게 되면 일부를 **잃어버리게** 된다.\n\n세 번째는 `작업 기억 공간`으로 컴퓨터의 프로세서와 같아서 LTM과 STM의 정보를 조합하여 연산하는 등의 사고 작용을 담당한다.\n\n## 객체의 역할, 책임, 협력\n\n'오브젝트'에서는 객체의 역할, 책임, 협력의 중요성에 대해서 강조하고 있다.\n\n하나의 시스템은 여러 객체의 협력을 통해서 만들어지고, 이 과정에서 각 객체는 고유의 역할과 책임을 가지고 다른 객체로부터의 메시지를 처리한다.\n\n이렇게 설계된 객체의 품질을 측정하는 척도로 응집도와 결합도가 사용될 수 있다.\n잘 설계된 객체일수록 내부 상태 값 간의 응집도가 높고 다른 객체와의 결합도는 낮다. 이런 설계는 변경에 대해 유연하게 대응할 수 있게 한다. 반면, 응집도가 낮고 결합도가 높은 설계는 유연성이 떨어지게 된다.\n\n이러한 응집도와 결합도를 결정하는 것은 캡슐화다. 즉, 잘 추상화된 객체가 좋은 설계를 의미하며, 객체의 품질은 캡슐화 수준에 따라 결정된다.\n\n확실히 추상화가 가져오는 이점은 많다. 추상화는 복잡한 시스템을 단순화하고, 코드의 재사용성을 높이며, 유지보수를 용이하게 하고, 소프트웨어 설계의 유연성을 향상한다.\n\n그러나 코드의 인지 과정에 대해 고려해 볼 때, 추상화 수준이 높아질수록 코드를 파악하는 데 필요한 노력이 증가할 수 있다는 생각이 들었다. 추상화가 복잡성을 감추는 동시에, 그 이해를 위해 더 많은 맥락을 파악해야 하기 때문이다.\n\n## 코드의 탈 국지화에 의한 인지 과부하\n\n객체 지향적으로 잘 작성된 코드는 SRP 원칙을 준수하며 변경 지점이 한곳이 되어 유지보수하기 좋은 코드가 된다.\n하지만 코드가 유지보수하기 좋게 수정되었다고 해서 반드시 가독성까지 좋아지는 것은 아니다.\n\n여러 객체의 협력이 필요한 복잡한 비즈니스 로직을 가정해 보자. 해당 로직을 구현하는 데 필요한 메시지들은 여러 적절한 객체에게 할당될 것이다. 그리고 각 객체는 자신에게 할당된 메시지를 처리하기 위해 필요한 정보를 갖고 있는 전문가에게 또 다른 메시지를 전달할 것이다.\n\n이때 캡슐화를 높이기 위해서 메서드에 전달하는 인자의 수마저 최소화한다면 개발자는 내부 구현을 파악하기 위해서 해당 메서드가 정의되어 있는 객체들을 찾아 찾아 넘나들어야만 한다.\n\n이렇게 탈 국지화된 코드는 여러 군데에서 메서드의 내부 구현을 찾아봐야 하므로 작업 기억 공간에는 어려움을 줄 수 있다.\n\n'프로그래머의 뇌'에서는 유지보수하기 좋은 코드를 작성하기보다는 장기적으로 가독성이 높은 코드로 리팩터링 하는 방식을 `인지적 리팩터링`이라고 소개하고 있다.\n\n그렇다면 객체지향을 통한 `유지보수`와 인지적 리팩터링을 통한 `가독성` 중 무엇을 선택해야 할까?\n\n## 표식을 통한 인지 과부하 개선\n\n변경될 가능성이 거의 없는 복잡한 비즈니스 로직이라면 인지적 리팩터링을 통한 가독성 개선을 고려해 볼 수 있다고 생각한다.\n\n하지만 그 외에 변경될 가능성이 조금이라도 존재하는 영역은 유지보수를 고려한 설계를 해야 한다고 생각한다.\n\n대신 탈 국지화에 의한 인지 과부하를 줄이기 위한 수단이 필요한데, 책에서는 **표식을** 남기는 것이 도움이 된다고 설명하고 있다. 여러 파일을 거쳐서 내부 구현을 파악하고 다니다 보면, 내부 구현을 파악하고 돌아왔을 때 그 내용을 잊어버리는 경우가 있을 수 있는데, 이때 내부 구현에 대한 내용을 함축한 표식을 보게 되면 쉽게 상기할 수 있다.\n\n여기에서 표식은 **주석**이 될 수 있다. 주석 사용 여부가 종종 개발자들 사이에서 논쟁거리가 되곤 하지만 개발자들은 코드를 읽을 때 주석 문에 굉장히 많이 의존하며 고수준의 주석 문은 코드를 청크 단위로 쪼개는 데 도움을 준다고 논문을 기반으로 책에서는 설명하고 있다. (반면 저수준의 주석 문은 오히려 청킹 작업에 부담을 준다)\n\n그렇다고 모든 함수의 결과를 주석으로 다는 것에 대해선 부정적으로 생각한다. 주석도 코드의 일부이기 때문에 코드를 파악하는 데 드는 시간이 늘어나기 때문이다. 코드 자체가 표식의 역할을 할 수 있다면 더 효율적일 것이다.\n\n주석 대신 메서드명과 변수명이 자신의 역할을 잘 표현하고 있다면 코드를 표식으로 사용하는게 가능해진다.\n이는 코드의 가독성을 자연스럽게 향상시키며, 개발자가 코드를 읽고 이해하는 데 소요되는 시간을 줄요준다.\n\n즉, 가독성과 유지보수성 사이의 트레이드 오프를 최소화 하기 위해서는, 코드의 구조를 잘 설계하는 것과 더불어, 각 구성 요소의 네이밍에도 신경을 써야한다.\n\n## 마무리\n\n두 책을 읽고 나서의 나의 견해를 정리하자면 변화의 가능성이 없는 로직의 경우 가독성을 우선시해도 괜찮다고 생각한다. 그러나 대부분의 경우 변화를 예측하기란 어려운 일이기 때문에 가능한 모든 영역에서 유지보수를 고려한 객체 지향적 설계를 해야만 한다고 생각한다. 대신 의미 있는 변수명과 메서드명을 부여하여 탈 국지화된 코드를 파악하는 과정에서 표식 역할을 할 수 있도록 하는 게 중요하다.\n\n변수명과 메서드명의 중요성은 OOP에 대해서 알기 이전인 프로그래밍을 처음 배웠을 때부터 들었던 내용이다.\n\n그만큼 중요하다는 것이었는데 다시 한번 기본의 중요성을 느낄 수 있었고, 어느 순간 네이밍의 중요성을 잊고 지냈던 자신을 반성하는 시간을 가지는 계기가 되었다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}