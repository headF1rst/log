{"pageProps":{"postData":{"id":"post8","lang":"ko","title":"[오브젝트] 5장 - 책임 할당하기","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-09-19 10:00","preview":"\n## 책임 중심 설계\n\n- 어떤 객체에게 어던 책임을 할당할지 결정해야한다\n- 문제 해결을 위한 다양한 책임 할당 방법이 존재하며 일종의 트레이드오프 활동이다.\n- 상황과 문맥에 따라 최적의 책임 할당 방법을 선택해야한다.\n\n- 책임 중심 설계를 위"},"detail":"\n## 책임 중심 설계\n\n- 어떤 객체에게 어던 책임을 할당할지 결정해야한다\n- 문제 해결을 위한 다양한 책임 할당 방법이 존재하며 일종의 트레이드오프 활동이다.\n- 상황과 문맥에 따라 최적의 책임 할당 방법을 선택해야한다.\n\n- 책임 중심 설계를 위한 원칙\n    - 데이터보다 행동을 먼저 결정\n        - 중요한 것은 데이터가 아닌 외부에 제공하는 행동 (객체의 책임)\n        - 객체가 수행해야 하는 책임이 무엇인지 결정 후, 책임을 수행하는 데 필요한 데이터를 결정\n    - 협력이라는 문맥 안에서 책임을 결정\n        - 객체 책임의 품질은 협력에 적합한 정도로 결정된다.\n        - 책임은 객체 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.\n        - 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당하라.\n        - 메시지가 객체를 선택하게 하라.\n\n- 메시지를 전송해야 하는데 누구에게 전송해야 하지? 라고 질문\n    - -> 메세지 기반 설계\n- 객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정\n    - -> 송신자 관점에서 수신자가 캡슐화됨\n\n## 책임 할당 GRASP 패턴\n\n- 설계 시작시 도메인을 책임 할당의 대상으로 사용하라. (도메인 모델 그리기)\n    - 개념들의 의미와 관계가 완벽할 필요 없다.\n    - 도메인 개념 정리에 시간투자 X. 설계를 시작하기 위한 개념들의 모음이면 충분\n- 어플리케이션이 제공해야하는 기능 -> 어플리케이션의 책임\n- 책임을 어플리케이션에 대해 전송된 메시지로 간주\n    - 메시지를 책임질 첫 번째 객체를 선택하는것으로 책임 주도 설계 시작\n\n### Information Expert 패턴\n\n- 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하라.\n    - 객체의 책임과 책임을 수행하는데 필요한 상태는 동일한 객체 안에 존재해야 한다.\n    - 정보와 행동이 가까이 있으면 캡슐화 유지됨 (응집도 높이고 결합도 낮추고)\n\n### Low Coupling & High Cohesion 패턴\n\n- 책임을 할당할 수 있는 다양한 대안이 존재한다면 응집도와 결합도 측면에서 더 나은 대안을 선택.\n\n### Creator 패턴\n\n- 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공\n- 객체 A를 생성해야 할 때 아래 조건을 최대한 만족하는 B에게 생성 책임을 할당\n    - B가 A 객체를 포함하거나 참조\n    - B가 A 객체를 기록\n    - B가 A 객체를 긴밀히 사용\n    - B가 A에 대한 정보 전문가다\n\n- 클래스 응집도 판단하는 방법 (변경의 이유가 하나 이상인 클래스를 찾는 방법)\n    - 변경의 이유를 기준으로 클래스를 분리하라 (SRP)\n    - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮다는 증거\n    - 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮다는 증거\n\n### Polymorphism 패턴\n\n- 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.\n    - 조건문을 사용해 설계하면 변경에 취약한 설계가 된다.\n    - 다형성을 이용해 변화를 다루기 쉽게 확장하라\n\n### Protected Varations 패턴\n\n- 변경될 가능성이 높다면 캡슐화하라.\n    - 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하라\n    - 결합도와 응집도 향상\n\n- 처음부터 책임 주도 설계를 따르는 것보다 동작하는 코드를 먼저 작성하고 리팩터링하는 것이 더 훌륭한 결과물을 낳을 수 있다.\n    - 객체로 책임을 분배할 때 메서드를 응집도 있는 수준으로 분해하라\n    - 자신이 소유하고 있는 데이터를 스스로 처리하도록 메서드를 알맞는 클래스에 배치하라\n        - 메서드를 다른 클래스로 이동시킬 때는 인자에 정의된 클래스 중 하나로 이동하는게 일반적\n\n## 느낀점\n\n책임주도 설계를 잘하기란 정말 어렵다. 때문에 책에서도 언급되었듯이 동작하는 코드를 먼저 작성하고 나서 책임주도 설계로 리팩터링 해나가고는 한다.\n\n하지만 코드의 스멜을 찾기는 생각보다 어려울 수 있고 리팩터링으로 인한 트레이드 오프를 개발자가 인지하지 못 할 수도 있다.\n\n이러한 이유에서 코드리뷰 문화는 코드의 품질을 높이는데 중요한 요소라고 생각하며 선한 피드백을 주고 받을 수 있는 동료가 될 수 있도록 노력하고 그러한 환경을 만드는데 기여해야겠다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}