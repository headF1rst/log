{"pageProps":{"postData":{"id":"post7","lang":"ko","title":"[오브젝트] 4장 - 설계 품질과 트레이드오프","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","section":"tech","tags":"객체지향","date":"2022-09-12 10:00","preview":"\n좋은 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 캡슐화를 통해 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 것\n\n- 구현\n    - 변경될 가능성이 높은 부분\n- 인터페이스\n    - 상대적으로 안정적인 부분\n\n- 변경의 정도에 "},"detail":"\n좋은 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 캡슐화를 통해 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 것\n\n- 구현\n    - 변경될 가능성이 높은 부분\n- 인터페이스\n    - 상대적으로 안정적인 부분\n\n- 변경의 정도에 따라 `구현`과 `인터페이스`를 분리\n    - 외부에서는 인터페이스에만 의존하도록 관계 조절\n    - 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 해야 한다. - OOP의 핵심\n\n- `캡슐화`\n    - 변경될 수 있는 어떤 것이라도 감추는 것\n    - 내부 구현 변경으로 인해 외부의 객체가 영향을 받으면 캡슐화 위반\n    - 설계시에 변하는게 무엇인지 고려하고 변하는 개념을 캡슐화하라\n- `응집도`\n    - 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력할 수록 높은 응집도\n    - 응집도가 낮으면 변경시에 여러 모듈을 수정해야함.\n- `결합도`\n    - 다른 모듈과의 의존성 정도\n    - 다른 모듈에 대해 꼭 필요한 지식만을 갖게 해서 결합도를 낮추는게 이상적.\n    - 결합도가 높으면 변경시에 여러 모듈을 수정해야함.\n\n응집도와 결합도 모두 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정 가능.\n\n### getter, setter를 지양하자 (추측에 의한 설계 전략 X)\n\n- getter, setter는 캡슐화를 위반.\n    - getFee, setFee 등 객체 내부에 fee라는 인스턴스 변수가 존재한다는걸 인터페이스에 나타냄\n    - 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문에 문제 발생\n    - 객체 내부 구현이 객체의 인터페이스에 드러난다.\n        - 객체 내부 구현을 변경하면 해당 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다. (High coupling)\n\n> 단일 책임 원칙 : 클래스는 단 한가지의 변경 이유만 가져야한다. - 응집도를 높이는 설계 원칙\n\n### 캡슐화 -> 높은 응집도, 낮은 결합도\n\n- 객체는 내부 데이터를 감추고 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근.\n- 의미있는 객체의 메서드\n    - = 객체가 책임져야 하는 무언가를 수행하는 메서드\n\n- 객체 스스로 자신의 상태를 처리해야한다.\n\n### 객체의 인터페이스에 구현이 노출되어 캡슐화가 깨진 경우\n\n`isDiscountTable(DayOfWeek dayOfWeek, LocalTime time)`\n\n- 해당 메서드는 객체 내부에 DayOfWeek과 LocalTime 타입의 정보가 인스턴스 변수로 포함되어 있다는 사실을 인터페이스를 통해 외부에 노출한다.\n- 객체 내부 속성을 변경하면 위 메서드의 파라미터를 수정하고 해당 메서드를 사용하는 모든 클라이언트도 함께 수정되야 한다.\n\n### 데이터 중심 설계의 문제점\n\n- 너무 이른 시기에 데이터에 관해 결정하도록 강요\n- 협력이라는 문맥을 고려하지 않음\n    - 객체를 고립시킨 채  오퍼레이션 결정\n\n### 느낀점\n\n많은 프로젝트에서 대부분의 로직은 서비스 레이어에 존재합니다.\n\n로직이 서비스레이어에 존재하게 되면 객체는 단순히 데이터를 제공하는 역할만을 하고 있을 가능성이 높습니다.\n\n가능한 객체 스스로 로직을 처리할 수 있는 구조로 변경해야 하며 서비스 레이어는 레포지토리 레이어와 소통해서 객체에 메시지를 전달하여 도메인이 로직을 처리할 수 있도록 하는 역할에 집중되어야 한다고 생각합니다.\n\n이러한 방식은 객체지향적인 구조를 제공할 뿐만 아니라 테스트를 더 용이하게 해줍니다.\n\n개인적으로 Mock을 사용하면 테스트 코드를 읽기 어려워지고 구현 비용도 크기 때문에 선호하지 않는데, 서비스 레이어의 로직을 객체로 옮기게 되면 Mock을 사용할 필요가 없어지기 때문에 테스트 작성 비용을 줄일 수 있지 않을까 생각해보았습니다.\n\n마지막으로 \"좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.\" 라는 말이 인상깊었던 구절이었습니다.\n\n이번장을 읽으면서 떠올렸던 객체지향 생활체조 원칙과 포스트 몇개를 찾아보았습니다.\n- [getter 메소드를 사용하지 않도록 리팩토링한다.](https://www.slipp.net/questions/565)\n- [\"getter를 사용하는 대신 객체에 메시지를 보내자\"](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/)\n- [\"객체지향 생활체조 원칙 9 - 게터/세터/프로퍼티를 쓰지 않는다\"](https://limdingdong.tistory.com/15)\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}