{"pageProps":{"postData":{"id":"post10","lang":"ko","title":"10억 달러짜리 실수 해결하기: JSpecify와 NullAway를 사용한 최신 Java Null 안전성","date":"2025-09-24","section":"tech","tags":"Java, JSpecify, Null 안전성, NullPointerException, 정적 분석","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"JSpecify 어노테이션과 NullAway 정적 분석을 사용하여 현대 Java 애플리케이션에서 NullPointerException을 제거하는 방법 학습","searchKeywords":"JSpecify, NullAway, Java null 안전성, NullPointerException 방지, 정적 분석","translationSlug":"post9","preview":"\n자바 프로그래밍을 처음 시작한 개발자부터 20년 경력의 시니어 개발자까지, 경력을 불문하고 개발자들이 가장 자주 마주치는 에러는 **NullPointerException**일 것입니다.\n\n![Top Crash Reasons](https://dev-t"},"detail":"\n자바 프로그래밍을 처음 시작한 개발자부터 20년 경력의 시니어 개발자까지, 경력을 불문하고 개발자들이 가장 자주 마주치는 에러는 **NullPointerException**일 것입니다.\n\n![Top Crash Reasons](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/v82uppsp39zvfkuuwr1m.png)\n\n실제로 한 통계 자료에 따르면 NullPointerException이 소프트웨어 결함 통계 2위에 해당할 정도로 많은 개발자가 NPE로 고통받고 있다고 하는데요.\n\n\"Null 참조를 만든 건 나의 10억 달러짜리 실수다\"라고 [토니 호어(Tony Hoare)](https://news.ycombinator.com/item?id=12427069)의 말도 너무 유명하죠.\n\n> \"I call it my billion-dollar mistake. It was the invention of the null reference in 1965. … This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\"\n\n이러한 null 안전성을 높이기 위해 Java에서는 다양한 시도들이 있었고, `Optional`, JSR 305의 `@NonNull` 어노테이션을 거쳐, 마침내 **JSpecify**가 표준 어노테이션으로 제정되었습니다.\n\n지금부터 JSpecify를 사용하여 어떻게 프로젝트에 안정성을 높일 수 있는지, 신규 프로젝트뿐만 아니라 기존 시스템에 도입하기에도 부담이 없을지에 대해 소개해 드리고자 합니다.\n\n## NullPointerException: 왜 여전히 문제인가?\n\n토큰을 추출하는 API를 호출하고, 그 결과를 아무런 확인 없이 사용하는 코드가 있습니다.\n\n```java\n// TokenExtractor.java\npublic interface TokenExtractor {\n    String extractToken(String authorization);\n}\n\n// Main.java\nTokenExtractor tokenExtractor = new DefaultTokenExtractor();\nString token = tokenExtractor.extractToken(\"some-auth-header\");\nSystem.out.println(\"Token length: \" + token.length()); // <-- NullPointerException 발생!\n```\n\n이 코드는 `extractToken` 메서드가 `null`을 반환할 가능성이 있을 때 `NullPointerException`을 발생시킵니다.\n\n`extractToken` 메서드가 `null`을 반환하게 되면 `token`에 `null`값이 들어가고 `token.length()`로 `token` 값에 접근할 때 `NullPointerException`이 발생하게 됩니다.\n\n이처럼 Java의 근본적인 문제는 Null 가능성(Nullability)이 암시적(implicit)이라는 점입니다.\n\nAPI 문서에 명시되어 있지 않으면 개발자는 반환 값이 null일 수 있는지 아닌지 알기 어렵고, 이는 오해와 버그로 이어지게 됩니다.\n\n## JSpecify: 명시적인 Null 안전성을 향한 표준\n\n이 문제를 해결하기 위해 Google, JetBrains, Spring 등 여러 팀이 협력하여 JSpecify 표준을 만들었습니다.\n\nJSpecify는 단순한 어노테이션 집합이 아니라, Null 안전성에 대한 명확한 명세를 제공하여 다양한 도구(IDE, 정적 분석기)가 일관되게 동작하도록 하는 것을 목표로 합니다.\n\nJSpecify는 Null 가능성을 세 가지 상태로 정의합니다.\n\n1. **미지정(Unspecified)**: Java의 기본 상태로, `null`일 수도 아닐 수도 있습니다.\n2. **Nullable (@Nullable)**: 명시적으로 `null` 값을 가질 수 있음을 나타냅니다.\n3. **Non-null (@NonNull)**: 절대 `null` 값을 가지지 않음을 보장합니다.\n\n![JSpecify Null](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qp2g74jw6udz7f0x9nbf.png)\n\n### JSpecify 의존성 추가\n\n```gradle\nimplementation 'org.jspecify:jspecify:1.0.0'\n```\n\n이제 `TokenExtractor` 인터페이스에 어노테이션을 추가하여 Null 가능성을 명시할 수 있습니다.\n\n```java\nimport org.jspecify.annotations.Nullable;\n\npublic interface TokenExtractor {\n  \n    @Nullable // 반환 값이 null일 수 있음을 명시\n    String extractToken(String authorization);\n}\n```\n\n이렇게 하면 IntelliJ IDEA와 같은 IDE는 `token.length()`를 호출하는 부분에서 잠재적인 `NullPointerException`을 경고해 주어, 개발자가 런타임 오류가 발생하기 전에 문제를 해결할 수 있게 도와줍니다.\n\n![IntelliJ IDE Null](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/i34w3oga4na12thlupwp.png)\n\n## 가독성 향상: `@NullMarked`로 기본값 설정하기\n\n대부분의 경우(약 90%) API는 `null`이 아닌 값을 다룹니다. 모든 매개변수와 반환 값에 `@NonNull`을 붙이는 것은 귀찮은 일이며 코드를 지저분하게 만들고 자칫 가독성을 해칠 수 있습니다.\n\n이를 해결하기 위해 JSpecify는 `@NullMarked` 어노테이션을 제공합니다.\n\n`@NullMarked` 어노테이션을 패키지 수준(`package-info.java` 파일)에 적용하면 해당 패키지 내의 모든 타입은 기본적으로 Non-null로 간주됩니다.\n\n```java\n// src/main/java/com/example/package-info.java\n@NullMarked\npackage com.example;\n\nimport org.jspecify.annotations.NullMarked;\n```\n\n이제 명시적으로 `@Nullable`을 붙인 경우를 제외하고는 모두 Non-null로 처리되므로 코드가 훨씬 깔끔하게 관리할 수 있습니다.\n\n## 빌드 시간 검증: NullAway로 Null 안전성 강화하기\n\nIDE의 경고는 유용하지만, 이를 무시하고 코드를 커밋하는 것을 막을 수는 없는데요.\n\nNull 안전성을 강제하기 위해 [NullAway](https://github.com/uber/NullAway)와 같은 정적 분석 도구를 사용할 수 있습니다. `NullAway`는 Error Prone의 플러그인으로, 빌드 과정에서 JSpecify 어노테이션을 분석하여 Null 안전성 위반 시 빌드를 실패시킵니다.\n\nGradle에 다음과 같이 설정할 수 있습니다.\n\n```gradle\nplugins {\n  id 'net.ltgt.errorprone' version '4.1.0'\n}\n\ndependencies {\n    implementation 'org.jspecify:jspecify:1.0.0'\n    \n    errorprone \"com.google.errorprone:error_prone_core:2.37.0\"\n    errorprone \"com.uber.nullaway:nullaway:0.12.6\"\n}\n\ntasks.withType(JavaCompile).configureEach {\n    options.errorprone {\n        disableAllChecks = true\n        option(\"NullAway:OnlyNullMarked\", \"true\")\n        error(\"NullAway\")\n    }\n}\n```\n\nIDE의 경고를 무시하고 빌드를 하면 다음과 같이 컴파일 시점에 에러가 발생하여 Null 안전성을 위반하는 코드가 배포되는 것을 막을 수 있습니다.\n\n![build error](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k82l826lqbmlzs5rclpu.png)\n\n## Spring 생태계에서의 JSpecify\n\nSpring Framework 7(Spring Boot 4에 포함)부터는 코드베이스 전체가 JSpecify 어노테이션으로 마이그레이션되었습니다. 이는 Spring 개발자들이 별도의 설정 없이도 Spring API의 Null 안전성 정보를 IDE와 빌드 도구에서 바로 활용할 수 있음을 의미합니다.\n\n예를 들어, `RestClient`의 `.body()` 메서드는 `@Nullable String`을 반환하므로, 개발자는 반환 값이 `null`일 가능성을 인지하고 적절히 처리해야 합니다.\n\n```java\n// Spring의 RestClient API\n@Nullable\nString body = restClient.get().uri(\"/user\").retrieve().body(String.class);\n\n// IDE는 body가 null일 수 있음을 경고\nSystem.out.println(body.length());\n```\n\n## 앞으로의 Java의 Null 안전성\n\n장기적으로 Java 언어 자체에 Null 안전성 기능이 도입될 예정이라고 하는데요.\n\n`?` (nullable)와 `!` (non-null) 같은 새로운 구문이 제안되었지만, Java의 하위 호환성 원칙 때문에 기본값은 여전히 \"미지정(unspecified)\"으로 남을 것이라고 합니다. [(https://openjdk.org/jeps/8303099)](https://openjdk.org/jeps/8303099)\n\n하지만 어디까지나 제안 단계이고 이 기능이 현실화되기까지는 수년이 걸릴 것이므로, 현재로서는 JSpecify와 NullAway가 Java 애플리케이션의 안정성을 높이는 가장 현실적이고 강력한 방법입니다.\n\n## 마무리\n\nJSpecify와 NullAway는 Java의 \"10억 달러짜리 실수\"를 해결하기 위한 강력한 조합입니다. 명시적인 어노테이션을 통해 코드의 의도를 명확히 하고, IDE와 빌드 도구를 연동하여 컴파일 시간에 잠재적인 NullPointerException을 제거할 수 있습니다.\n\n실제로 팀에 JSpecify를 공유하고 프로젝트에 적용하면서 느낀 경험에 비추어 볼때, 간단한 설정으로 애플리케이션 안정성과 코드 품질이 향상되는 것을 경험하였으며, 패키지 단위의 점진적 도입이 가능하기 때문에 기존 프로젝트에 적용하는 데 부담이 적다는 것 역시 큰 장점으로 느껴졌습니다.\n\n이 글을 읽어주시는 분들께서도 JSpecify를 프로젝트에 적용하여 더 안전하고 견고한 코드를 작성해 보시기 바랍니다.","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}