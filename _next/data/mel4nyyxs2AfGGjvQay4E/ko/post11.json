{"pageProps":{"postData":{"id":"post11","lang":"ko","title":"[오브젝트] 7장 - 객체 분해","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-10-02 10:00","preview":"\n모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능\n\n## 추상화 메커니즘\n시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.\n\n- 1. 프로시저 추상화\n    - 소프트웨어가 무엇을 **해야**하는지 "},"detail":"\n모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능\n\n## 추상화 메커니즘\n시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.\n\n- 1. 프로시저 추상화\n    - 소프트웨어가 무엇을 **해야**하는지 추상화\n    - 기능 분해\n        - 기능 구현을 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정\n- 2. 데이터 추상화\n    - 소프트웨어가 무엇을 **알아야** 하는지 추상화\n    - 타입을 추상화(추상 데이터 타입) vs 프로시저를 추상화(객체지향)\n        - 타입을 추상화 하면 `추상 데이터 타입`\n        - 프로시저를 추상화 하면 `객체지향`\n\n## 1. 프로시저 추상화와 기능 분해\n\n- 프로시저\n    - 반복적으로 수행되는 작업을 한 장소에 모아서 로직을 재사용하고 중복을 방지하는 추상화 방법\n    - 내부의 상세 구현을 모르더라도 인터페이스만 알면 프로시저 사용 가능.\n    - 기능 분해 방식 - **하향식 접근법**\n\n### 하향식 접근법\n\n최상위 기능을 정의하고(메인 함수) 덜 추상적인 하위 기능으로 분해해 나가는 방법\n\n#### 하향식 접근법의 문제점\n\n- 현대 시스템은 동등한 수준의 다양한 기능으로 구성된다.\n- 대부분의 시스템은 하나의 메임 함수로 구성돼 있지 않다.\n    - \"실제 시스템에 정상이란 존재하지 않는다\"\n- 요구사항 변경시 메인 함수를 빈번하게 변경해야 한다.\n- 로직이 사용자 인터페이스와 강하게 결합되어있다.\n- 데이터 형식이 변경될 경우 관련된 모든 함수를 수정해야한다.\n- 설계 시작부터 시스템이 **어떻게** 동작해야 하는지에 집중하게 한다.\n- 이른 시기에 함수 실행 순서를 고정하여 유연성과 재사용성이 떨어진다.\n\n이와 같은 기능 분해의 문제를 해결하기 위해 정보 은닉과 모듈 개념이 등장.\n\n## 모듈\n\n- 변경의 방향에 맞춰 시스템을 분해하라\n- 함께 변경되는 부분을 하나의 구현 단위(모듈)로 묶고 퍼블릭 인터페이스를 통해서만 접근 가능하도록 만드는 것. (높은 응집도, 낮은 결합도)\n- 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터, 함수의 집합.\n\n### 정보 은닉\n\n시스템을 모듈 단위로 분해하기 위한 기본 원리.\n\n시스템에서 **자주 변경되는 부분을** 상대적으로 덜 변경되는 **인터페이스 뒤로 감춰라.**\n\n- 모듈 분해\n    - 감춰야 하는 정보를 선택하고 정보를 안정적인 보호막(퍼블릭 인터페이스)을 통해 보존하는 과정\n    - 모듈 분해 후, 기능 분해를 통해서 모듈에 필요한 퍼블릭 인터페이스를 구현\n\n### 모듈의 장점과 한계\n\n#### 장점\n\n- 모듈 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드 수정 및 디버깅이 용이하다.\n- 비즈니스 로직과 사용자 인터페이스에 대한 관심사가 분리된다.\n- 전역 변수와 전역 함수를 제거하여 네임스페이스 오염을 방지한다.\n\n#### 단점\n\n- 인스턴스의 개념을 제공하지 않는다.\n\n이러한 단점을 개선하기 위해 `추상 데이터 타입`이라는 개념이 등장.\n\n## 2. 데이터 추상화\n\n### 추상 데이터 타입\n\n- 프로그래밍 언어가 제공하는 타입처럼 동작하는 **사용자 정의 타입**\n- 타입을 개발자가 정의할 수 있다.\n- 하나의 물리적 타입 안에 개념적 타입에 대한 구현을 감춘다.\n\n### 클래스는 추상 데이터 타입인가?\n\n#### 클래스와 추상 데이터 타입의 차이\n\n- 클래스\n    - 상속과 다형성을 지원 - 객체지향 프로그래밍\n    - 절차를 추상화 한것\n    - 타입을 기준으로 오퍼레이션을 묶는다.\n- 추상 데이터 타입\n    - 상속과 다형성 지원 X - 객체기반 프로그래밍\n    - 타입을 추상화 한것\n    - 오퍼레이션을 기준으로 타입을 묶는다\n\n- 클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법\n    - 클래스 내부에 인스턴스의 타입을 표현하는 변수의 유무\n        - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는건 객체지향을 위반\n    - 타입을 기준으로 절차를 추상화하지 않았다면 객체지향 분해가 아니다.\n\n## 변경을 기준으로 선택하라\n\n설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.\n\n- 클래스 구조를 선택하는 경우\n    - 타입 추가라는 변경의 압력이 더 강한 경우\n        - 새로운 타입을 빈번하게 추가해야 하는 경우\n- 추상 데이터 타입을 선택하는 경우\n    - 변경의 주된 압력이 오퍼레이션 추가인 경우\n        - 새로운 오퍼레이션을 빈번하게 추가해야 하는 경우\n\n변경의 축을 찾아야 한다.\n객체지향적인 접근법이 은총알은 아니다.\n\n## 느낀점\n\n추상 데이터 타입이 사용된 예가 뭐가있을지 고민해 보았는데 스택과 같은 자료구조가 떠올랐다.\n\n자료구조 수업에서 C++로 스택과 연결 리스트 등을 구현해 보았었는데, 이번 기회에 자바로도 한번 구현해 보도록 해야겠다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}