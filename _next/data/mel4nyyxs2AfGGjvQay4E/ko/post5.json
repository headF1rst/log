{"pageProps":{"postData":{"id":"post5","lang":"ko","title":"[오브젝트] 2장 - 객체지향 프로그래밍","section":"tech","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"객체지향","date":"2022-08-29 10:00","preview":"\n클래스를 먼저 결정하고, 어떤 `속성`과 `메서드`가 필요한지 고민하는것리 아니라 `객체`에 초점을 맞춰야한다\n\n1. 어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라\n   클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것\n\n2."},"detail":"\n클래스를 먼저 결정하고, 어떤 `속성`과 `메서드`가 필요한지 고민하는것리 아니라 `객체`에 초점을 맞춰야한다\n\n1. 어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라\n   클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것\n\n2. 객체는 독립적인 존재가아닌 협력하는 공동체의 일원이다\n\n- 객체의 윤곽을 잡고 공통된 특성과 상태를 가진 객체들을 **타입** 으로 분류하라\n- 타입을 기반으로 클래스를 구현하라\n\n클래스의 내부와 외부를 구분. 경계를 명확하게하여 객체의 자율성을 보장한다 -> 개발자의 구현의 자유 제공\n\n객체는 상태와 행동을 갖고 스스로 판단하고 행동하는 자율적인 존재\n\n데이터와 기능을 객체 내부로 함께 묶는것 -> `캡슐화`\n\n- 객체를 이용해서 타입을 정의하도록 하자\n    - 의미를 명시적이고 분명하게 표현 할 수 있으며 이는 설계의 명확성과 유연성을 높인다\n\n협력 관점에서 어떤 객체가 필요할지 결정하고 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성\n\n### 의존성의 양면성\n\n코드의 의존성과 실행시점의 의존성은 다를수 있다.\n두 의존성이 다르면 다를수록 코드는 더 유연해지고 확장성이 좋아진다.\n\n반면 코드를 이해하기 위해서는 객체를 생성하고 연결하는 부분을 찾아야하기 때문에 코드를 이해하기는 힘들어진다\n\n설계는 곧 `트레이드오프의 산물`.\n\n### 다형성\n\n\n인터페이스 -> 객체가 이해할 수 있는 메시지의 목록을 정의\n\n메세지와 메서드는 다른개념이다.\n\n예를들어 영화 객체가 할인 정책 객체의 인스턴스에 calculateDiscountPolicy 메시지를 전송한다.\n\n실행되는 메서드는 영화와 협력하는 객체, 즉 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. - `다형성`\n\n다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실핼 시간 의존성이 다를 수 있다는 사실을 기반으로 한다\n\n다형적 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다 -> 인터페이스가 동일해야 한다\n\n인터페이스를 통일하기 위해 사용한 방법 -> 상속\n\n**동적 바인딩:** 메시지와 메서드를 실행 시점에 바인딩\n\n**정적 바인딩**: 컴파일 시점에 실행될 함수나 프로시저를 결정하는것\n\n우리는 동적 바인딩 메커니즘을 사용하여 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고 하나의 메시지를 선택적으로 다른 메서드에 연결할 수 있다\n\n상속을 사용하여 동일한 인터페이스를 공유하는 클래스들을 하나의 **타입 계층**으로 묶을수 있다\n\n### 구현 상속과 인터페이스 상속\n\n**구현 상속 (서브클래싱)** : 코드 재사용 목적으로 상속을 사용한 경우\n\n**인터페이스 상속 (서브타이핑)** : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유 할 수 있도록 상속을 사용한 경우\n\n인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 생산할 수 있다\n\n### 추상화의 장점\n- 추상화의 계층만 따로 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다\n- 상위 정책을 기술하여 어플리케이션의 협력 흐름을 술\n- 설계가 유연해진다\n\n### 유연한 설계\n예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라\n\n유연성이 필요한 곳에 추상화를 사용하라\n\n### 코드 재사용\n코드를 재사용 하기 위해서는 상속보다는 **합성**을 사용하라\n\n### 코드 재사용으로 상속을 지양하는 이유\n\n코드 재사용을 목적으로 상속을 사용하면 설계에 안좋은 영형을 끼친다.\n\n- 캡슐화를 위반\n  상속을 이용하기 위해서 개발자는 부모 클래스릐 내부 구조를 알아야한다\n\n결과적으로 부모 클래스가 자식 클랴스에 노출되어 캡슐화가 약화된다\n\n캡슐화가 약화되어 자식이 부모 클래스와 강하게 결합되기 때문에 부모 클래스가 변경되면 자식 클래스도 함께 변경되야 한다\n\n- 유연하지 못한 설계\n  부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정하기 때문에 실행 시점에 객체 종류 변경이 불가능\n\n### 합성을 사용해서 코드를 재사용하자\n\n`합성`\n- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법.\n\n``` java\npublic class Movie {\n    ...\n    private DiscountPolicy discountPolicy;\n    ...\n\n    public Money calculateMovieFee(Screening screening) {\n        return fee.minus(discountPolicy.calculateDiscountAmount(screening));\n    }\n}\n```\n\n`Movie`는 요금 계산을 위해 `DiscountPolicy`의 `calculateDiscountAmount()` 코드를 재사용한다.\n\n`Movie`는 `DiscountPolicy`인터페이스를 통해 약하게 결합되어있다 (의존하고 있다).\n\n실제로 `Movie`는 `DiscountPolicy`가 외부에 `calculateDiscountAmount()` 메서드를 제공한다는 것만 알고 내부 구현에 대해서는 전혀 모른다.\n\n\n합성의 장점은 다음과 같다\n\n- 구현을 효과적으로 캡슐화\n  인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에.\n\n- 유연한 설계\n  의존하는 인스턴스를 교체하는것이 쉽다.\n\n상속은 클래스를 통해 강하게 결합된다.\n합성은 메시지를 통해 느슨하게 결합된다.\n\n### 상속을 무조건 쓰지 말라는건 아니다\n\n코드를 재사용하는 경우에는 상속보다는 합성을 선호하는 것이 옳다.\n\n하지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용한다.\n\n---\n\n`객체지향 설계의 핵심`:\n- 적절한 협력을 식별\n- 협력에 필요한 역할을 정의\n- 역할을 수행할 수 있는 적절한 객체에 적절한 책임을 할당\n\n### 느낀점\n\n이번 장을 읽으면서, 과거에 한 친구가 단순히 중복을 제거하는 목적으로 상속을 사용한 설계를 저에게 보여줬던 것이 생각났습니다.\n\n당시에도 그러한 설계가 좋지 않은 설계라는걸 알고는 있었지만 모호하게 알고있었기 때문에, 그 친구에게 제 의견을 제대로 전달하지 못했던 경험을 하였습니다.\n\n나 혼자서 아무리 유연한 코드를 짜고 객체지향에 대해 잘 안다고 해도 결국에 하나의 프로젝트는 조직원들이 다 같이 완성해 나가는 것이기 때문에, 팀원들을 설득하지 못한다면 결과물은 객체지향적이지 않은 코드가 나오고 말것입니다.\n\n따라서 내가 배운것을 스스로 적용해 볼 수 있는 수준에서 그치지 않고 누군가에게 설명하고 설득할 수 있는 수준까지 공부하는것이 중요하다는 생각을 해보았습니다.\n","lang":"ko","allPostsInOtherLang":[{"id":"post9","lang":"en","title":"Solving the Billion-Dollar Mistake: Modern Java Null Safety with JSpecify and NullAway","date":"2025-09-24","section":"tech","tags":"Null Safety","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Ftotx4mdagz9nsegld5mr.png","description":"Learn how to eliminate NullPointerExceptions using JSpecify annotations and NullAway static analysis in modern Java applications","searchKeywords":"JSpecify, NullAway, Java null safety, NullPointerException prevention, static analysis","translationSlug":"post10","preview":"\nWhether you're a developer just starting with Java or a senior engineer with two decades of experience, the most frequently encountered err"},{"id":"post8","lang":"en","title":"PostgreSQL MVCC Internals: From xmin/xmax to Isolation Levels","date":"2025-07-06","section":"tech","tags":"PostgreSQL","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7rk467sodudw3ww7iisi.png","description":"Deep dive into PostgreSQL's MVCC implementation, understanding xmin/xmax and how different isolation levels work internally","searchKeywords":"PostgreSQL, MVCC, xmin, xmax, transaction, isolation level, concurrency control","preview":"\nWhen multiple users access a database concurrently, how can we guarantee Isolation, one of the core `ACID` properties? While we could apply"},{"id":"post7","lang":"en","title":"Prompt Engineering Tips from Anthropic Engineers","date":"2025-06-24","section":"tech","tags":"Prompt Engineering, AI, Anthropic, LLM","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fdzzrfth8zqdnrhbj9538.png","description":"Valuable prompt engineering tips and insights from Anthropic engineers","searchKeywords":"prompt engineering, AI tips, Anthropic, LLM best practices","translationSlug":"post22","preview":"\nHere are a few impressive points from [youtube (AI prompt engineering: A deep dive)](https://www.youtube.com/watch?v=T9aRN5JkmL8&t=2463s) w"},{"id":"post6","lang":"en","title":"From Theory to Practice: A JMH Showdown Between Sequential and Parallel Streams","date":"2025-06-15","section":"tech","tags":"Java, JMH","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F7ytq239pcfe279t9avzg.png","description":"Practical performance comparison between sequential and parallel streams using JMH benchmarking","searchKeywords":"JMH benchmark, Java performance, sequential vs parallel, stream optimization","preview":"\nIn our [previous post](https://dev.to/headf1rst/discover-how-forkjoinpool-powers-javas-high-performance-parallel-processing-3pn7), we delve"},{"id":"post5","lang":"en","title":"Discover how ForkJoinPool powers Java's high-performance parallel processing","date":"2025-06-03","section":"tech","tags":"ForkJoinPool","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qgawc6pj2vbyzuem20wn.png","description":"Understanding ForkJoinPool and how it powers Java's parallel stream processing","searchKeywords":"ForkJoinPool, Java parallel processing, work-stealing, parallelStream","preview":"\nRecently, I optimized our transport operation plan Excel upload feature, boosting performance for logistics system administrators. This too"},{"id":"post4","lang":"en","title":"Why @Transactional Sometimes Fails: A Deep Dive into Spring AOP Proxies","section":"tech","date":"2025-06-01","tags":"AOP, Transactional","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a1wxef2amdixh3lr4any.png","description":"Understanding Spring AOP proxies and why @Transactional sometimes fails with internal method calls","searchKeywords":"Spring AOP, @Transactional, proxy pattern, self-invocation","preview":"\n## How @Transactional Works\n\n### Transaction Management via AOP and the Proxy Pattern\n\nAOP (Aspect-Oriented Programming) is a programming p"},{"id":"post3","lang":"en","title":"Java ClassLoaders: How the JVM Dynamically Loads & Executes Your Code","section":"tech","date":"2025-05-27","tags":"Java","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iu4pe4d29jz23wt26kwz.png","description":"Deep dive into Java ClassLoaders and JVM's dynamic class loading mechanisms","searchKeywords":"Java ClassLoader, JVM, dynamic loading, class loading process","preview":"\nJava's \"Write Once, Run Anywhere\" principle is foundational to its sustained popularity. This portability is powered by the Java Virtual Ma"},{"id":"post2","lang":"en","title":"Understanding and Resolving the N+1 Query Problem in JPA","section":"tech","date":"2025-05-05","tags":"JPA, Hibernate, N+1 Problem","thumbnail":"https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsrf6chohgt3athvqj7u1.png","description":"Learn what causes the N+1 query problem in JPA, how to identify it, and practical solutions using fetch joins, EntityGraph, and QueryDSL","searchKeywords":"JPA, N+1, Hibernate, performance, optimization, fetch join, EntityGraph, QueryDSL","preview":"\nThe **N+1 query problem** arises when one initial query (1) is followed by N additional queries—one for each result row from the first quer"},{"id":"post1","lang":"en","title":"Kafka Producer Stability Check: Ensuring Message Safety in Apache Kafka","section":"tech","date":"2025-05-04","tags":"Kafka, Producer, Reliability, Apache Kafka","thumbnail":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ojt2w7s7rr9kws35r2yg.png","description":"Learn how to build fault-tolerant Kafka producers that survive rolling patches and broker failures","searchKeywords":"Kafka, producer, reliability, message safety, rolling patch, broker failure","preview":"\nDuring a recent incident, our team observed message loss from a Kafka producer during an Amazon MSK rolling patch. What began as a routine "}]},"__N_SSG":true}